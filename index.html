<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Home Poker Tournament Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QQ737235G7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QQ737235G7');
    </script>
    <!-- jsPDF & jsPDF-AutoTable from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js"></script>

    <style>
        :root {
            --bg-body: #020617;
            --bg-shell: radial-gradient(circle at top, #0b1120 0, #020617 55%, #020617 100%);
            --bg-card: linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.98));
            --bg-preview: radial-gradient(circle at top left, #020617 0, #020617 55%, #020617 100%);

            --border-soft: rgba(148, 163, 184, 0.3);
            --border-strong: rgba(15, 23, 42, 0.9);

            --accent: #22c55e;
            --accent-soft: #4ade80;

            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --text-soft: #6b7280;

            --chip-pill-bg: rgba(15, 23, 42, 0.85);
            --chip-pill-border: rgba(148, 163, 184, 0.35);

            --table-header-bg: #020617;
            --table-row-alt: rgba(15, 23, 42, 0.9);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 24px 10px;
            min-height: 100vh;
            background: var(--bg-body);
            background-image: radial-gradient(circle at top left, #1f2937 0, #020617 60%);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                "Segoe UI", sans-serif;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .app-shell {
            max-width: 1160px;
            width: 100%;
            background: var(--bg-shell);
            border-radius: 22px;
            padding: 22px 18px 24px;
            box-shadow:
                0 30px 80px rgba(0, 0, 0, 0.85),
                0 0 0 1px rgba(15, 23, 42, 0.95);
        }

        @media (min-width: 900px) {
            .app-shell {
                padding: 24px 28px 26px;
            }
        }

        header {
            text-align: center;
            margin-bottom: 16px;
        }

        header h1 {
            margin: 0;
            font-size: 1.9rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        .subtitle {
            margin-top: 6px;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .layout {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        @media (min-width: 900px) {
            .layout {
                flex-direction: row;
                align-items: flex-start;
                gap: 18px;
            }
        }

        .left-column {
            flex: 1.1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        .preview-card {
            flex: 1;
            min-width: 0;
            background: var(--bg-preview);
        }

        .card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 14px 14px 15px;
            box-shadow:
                0 14px 40px rgba(15, 23, 42, 0.8),
                inset 0 0 0 1px var(--border-soft);
            backdrop-filter: blur(18px);
        }

        .card h2 {
            margin: 0 0 8px;
            font-size: 0.98rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 7px 14px;
        }

        @media (min-width: 640px) {
            .form-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 3px;
            font-size: 0.85rem;
        }

        .form-row span.helper {
            font-size: 0.75rem;
            color: var(--text-soft);
        }

        label {
            font-size: 0.8rem;
            text-transform: none;
        }

        input[type="number"],
        input[type="text"],
        select {
            border-radius: 10px;
            border: 1px solid #4b5563;
            background: #020617;
            padding: 6px 10px;
            color: var(--text-main);
            font-size: 0.9rem;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
            border-color: var(--accent);
        }

        .inline-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            font-size: 0.82rem;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.83rem;
            margin-top: 2px;
        }

        input[type="checkbox"] {
            width: 15px;
            height: 15px;
            accent-color: var(--accent);
        }

        .breaks-config,
        .rebuys-config {
            margin-top: 5px;
            padding: 7px 9px;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.97);
            border: 1px dashed rgba(148, 163, 184, 0.8);
            font-size: 0.78rem;
        }

        .btn-row {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        button {
            border-radius: 999px;
            border: none;
            padding: 8px 18px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: radial-gradient(circle at top left, var(--accent-soft), var(--accent));
            color: #022c22;
            box-shadow:
                0 12px 30px rgba(34, 197, 94, 0.55),
                0 0 0 1px rgba(22, 101, 52, 0.9);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition:
                transform 0.08s ease,
                box-shadow 0.08s ease,
                filter 0.08s ease;
        }

        button:hover {
            filter: brightness(1.05);
        }

        button:active {
            transform: translateY(1px);
            box-shadow:
                0 8px 20px rgba(34, 197, 94, 0.45),
                0 0 0 1px rgba(22, 101, 52, 0.9);
        }

        .small-note {
            font-size: 0.74rem;
            color: var(--text-soft);
        }

        .small-note.muted {
            color: var(--text-muted);
        }

        .error {
            margin-top: 6px;
            font-size: 0.8rem;
            color: #fecaca;
        }

        .preview-header {
            margin-bottom: 6px;
        }

        .preview-title {
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .preview-subtitle {
            font-size: 0.8rem;
            color: var(--text-soft);
        }

        .preview-section-title {
            font-size: 0.88rem;
            font-weight: 600;
            margin-top: 8px;
            margin-bottom: 3px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.78rem;
        }

        th,
        td {
            padding: 4px 6px;
            border-bottom: 1px solid rgba(31, 41, 55, 0.9);
            text-align: left;
            white-space: nowrap;
        }

        th {
            font-weight: 600;
            color: var(--text-main);
            background: #020617;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        tr:nth-child(even) td {
            background: rgba(15, 23, 42, 0.6);
        }

        .scroll-box {
            max-height: 220px;
            overflow: auto;
            border-radius: 12px;
            border: 1px solid var(--border-strong);
            background: radial-gradient(circle at top left, #020617 0, #020617 60%);
            padding: 3px;
        }

        .chip-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 9px;
            border-radius: 999px;
            background: var(--chip-pill-bg);
            border: 1px solid var(--chip-pill-border);
            font-size: 0.75rem;
            color: var(--text-soft);
        }

        .chip-pill span {
            font-weight: 500;
            color: var(--text-main);
        }

        .pill-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        /* --- Extra polish & green accents --- */

        .app-shell {
            position: relative;
            overflow: hidden;
        }

        /* Thin neon rail at the top edge of the shell */
        .app-shell::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            width: 180px;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(90deg,
                    transparent,
                    var(--accent-soft),
                    var(--accent),
                    var(--accent-soft),
                    transparent);
            opacity: 0.95;
        }

        /* Subtle inner border to make the whole thing feel like a device frame */
        .app-shell::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 22px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            pointer-events: none;
        }

        /* Title glow */
        header h1 {
            text-shadow:
                0 0 18px rgba(34, 197, 94, 0.35),
                0 0 2px rgba(15, 23, 42, 0.9);
        }

        /* Suits row wow-factor under title */
        .suits-row {
            margin-top: 6px;
            display: flex;
            justify-content: center;
            gap: 10px;
            font-size: 1rem;
            letter-spacing: 0.3em;
        }

        .suits-row .spade,
        .suits-row .club {
            color: var(--text-main);
        }

        .suits-row .heart,
        .suits-row .diamond {
            color: #f87171;
        }

        /* Green accent stripe on card headings */
        .card h2 {
            position: relative;
            padding-left: 9px;
        }

        .card h2::before {
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 70%;
            border-radius: 999px;
            background: linear-gradient(180deg,
                    var(--accent),
                    var(--accent-soft));
        }

        /* Green accent lines in preview section headings */
        .preview-section-title {
            position: relative;
            padding-left: 6px;
        }

        .preview-section-title::before {
            content: "";
            position: absolute;
            left: 0;
            bottom: 0;
            width: 16px;
            height: 2px;
            border-radius: 999px;
            background: linear-gradient(90deg,
                    var(--accent),
                    transparent);
        }

        /* Slight green tint on table header bottom border */
        th {
            border-bottom: 1px solid rgba(34, 197, 94, 0.8);
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <header>
            <h1>POKER GAME PLANNER</h1>
            <p class="subtitle">
                Tune runtime, breaks, rebuys, and chip inventory. Get a suggested starting stack and blind schedule.
            </p>
            <div class="suits-row">
                <span class="spade">â™ </span>
                <span class="heart">â™¥</span>
                <span class="diamond">â™¦</span>
                <span class="club">â™£</span>
            </div>
        </header>

        <div class="layout">
            <!-- LEFT COLUMN: Setup + Chip Configuration -->
            <div class="left-column">
                <!-- Setup card -->
                <section class="card form-card">
                    <h2>Setup</h2>
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="tournamentName">Name</label>
                            <input id="tournamentName" type="text" placeholder="Friday Night Poker" />
                            <span class="helper">
                                This will appear at the top of the PDF and in the summary.
                            </span>
                        </div>
                        <div class="form-row">
                            <label for="players">Number of players</label>
                            <input id="players" type="number" min="3" max="10" value="6" />
                            <span class="helper">Designed for 3â€“10 players.</span>
                        </div>

                        <div class="form-row">
                            <label for="runtimeHours">Desired runtime (hours)</label>
                            <input id="runtimeHours" type="number" step="0.5" min="2" max="8" value="4" />
                            <span class="helper">Total duration including breaks.</span>
                        </div>

                        <div class="form-row">
                            <label for="structureSpeed">Structure speed</label>
                            <select id="structureSpeed">
                                <option value="slow">Slow (deeper, longer)</option>
                                <option value="normal" selected>Normal</option>
                                <option value="turbo">Turbo (faster)</option>
                            </select>
                            <span class="helper">
                                Controls how quickly blinds grow for the same runtime.
                            </span>
                        </div>

                        <div class="form-row">
                            <div class="checkbox-row">
                                <input id="useBreaks" type="checkbox" />
                                <label for="useBreaks">Schedule breaks?</label>
                            </div>
                            <div id="breaksConfig" class="breaks-config" style="display:none;">
                                <div class="form-row" style="margin-top:2px;">
                                    <label for="breakMinutes">Break length</label>
                                    <div class="inline-row">
                                        <input id="breakMinutes" type="number" min="3" max="30" value="5"
                                            style="width:80px;" />
                                        <span>minutes</span>
                                    </div>
                                </div>

                                <div class="form-row" style="margin-top:4px;">
                                    <label for="breakFrequencyHours">Time between breaks</label>
                                    <div class="inline-row">
                                        <input id="breakFrequencyHours" type="number" step="0.5" min="0.5" max="4"
                                            value="1.5" style="width:80px;" />
                                        <span>hours</span>
                                    </div>
                                    <span class="helper">Breaks are placed at levels closest to these time marks.</span>
                                </div>
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="checkbox-row">
                                <input id="allowRebuys" type="checkbox" />
                                <label for="allowRebuys">Allow rebuys?</label>
                            </div>
                            <div id="rebuysConfig" class="rebuys-config" style="display:none;">
                                <div class="inline-row">
                                    <span>Rebuys allowed until</span>
                                    <input id="rebuyCutoffHours" type="number" step="0.5" min="0.5" max="6" value="2"
                                        style="width:70px;" />
                                    <span>hours after start.</span>
                                </div>
                                <span class="helper">Each rebuy uses the same stack as the initial buy-in.</span>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Chip Setup card -->
                <section class="card">
                    <h2>Chip Setup</h2>
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="chipColorsCount">Number of chip colors:</label>
                            <input id="chipColorsCount" type="number" min="1" max="5" value="4" />
                            <span class="helper">
                                Choose from White, Red, Green, Blue, Black. The app assumes the usual value order.
                            </span>
                        </div>
                    </div>

                    <div id="chipColorsContainer" style="margin-top: 8px;">
                        <!-- Rows created via JS -->
                    </div>

                    <div class="form-row" style="margin-top: 10px;">
                        <label>How many of the total chips should starting stacks use?</label>
                        <div class="inline-row" style="flex-wrap: wrap; gap: 8px;">
                            <label><input type="radio" name="stackUsageMode" value="some" checked /> Some</label>
                            <label><input type="radio" name="stackUsageMode" value="half" /> About half</label>
                            <label><input type="radio" name="stackUsageMode" value="most" /> Most</label>
                            <label><input type="radio" name="stackUsageMode" value="max" /> As many as possible</label>
                        </div>
                        <span class="helper" id="stackUsageHelper">
                            We'll choose a stack size based on total chips and player count.
                        </span>
                    </div>

                    <div class="form-row" style="margin-top: 8px;">
                        <label>Chip value scale</label>
                        <div class="inline-row">
                            <button type="button" id="decreaseValuesBtn">Decrease values</button>
                            <button type="button" id="increaseValuesBtn">Increase values</button>
                        </div>
                        <span class="helper" id="valueScaleLabel">
                            Current values will be shown here after you enter chip colors.
                        </span>
                    </div>

                    <div class="small-note" id="chipSummaryNote" style="margin-top: 6px;">
                        Enter chip counts above to see a suggested starting stack per player.
                    </div>
                    <div class="form-row" style="margin-top: 8px;">
                        <label for="pdfStyle">PDF style</label>
                        <select id="pdfStyle">
                            <option value="mobile">Mobile-friendly (dark)</option>
                            <option value="print">Printer-friendly (light)</option>
                        </select>
                        <span class="helper">
                            Choose a dark, on-screen guide or a light version thatâ€™s easier to print.
                        </span>
                    </div>
                    <div class="btn-row">
                        <button id="generateBtn" type="button">
                            <span>Generate PDF Guide</span>
                        </button>
                        <span class="small-note">
                            The PDF opens in a new tab so you can save or share it.
                        </span>
                    </div>
                    <div id="errorBox" class="error" style="display:none;"></div>
                </section>
            </div>

            <!-- RIGHT COLUMN: preview -->
            <section class="card preview-card">
                <div class="preview-header">
                    <h2>Live Preview</h2>
                    <span class="small-note muted">
                        Adjust settings on the left to see stack suggestions and blind levels.
                    </span>
                </div>

                <div id="previewContent">
                    <p class="small-note muted">
                        Enter players, runtime, and chip info to see the suggested structure.
                    </p>
                </div>
            </section>
        </div>
    </div>

    <script>
        'use strict';

        // --- Helpers & globals ---
        function clamp(v, min, max) {
            if (isNaN(v)) return min;
            return Math.max(min, Math.min(max, v));
        }
        function roundToUnit(value, unit) {
            if (!unit || unit <= 0) return Math.round(value);
            return Math.max(unit, Math.round(value / unit) * unit);
        }

        const COLOR_OPTIONS = ['White', 'Red', 'Green', 'Blue', 'Black'];
        let chipColorRows = [];            // { colorSelect, countInput }
        let currentStackSuggestion = null; // { chipsPerPlayer, totalValuePerPlayer, colors[] }
        let valueScaleStep = 0;            // 0 = base, +1 = x2, -1 = x0.5, etc.
        const MIN_CHIPS_PER_PLAYER = 12;

        window.addEventListener('load', () => {
            setupFormInteractions();
            initChipColorsUI();

            // Force default states (iOS browsers like to restore old states)
            document.getElementById('useBreaks').checked = false;
            document.getElementById('allowRebuys').checked = false;

            document.getElementById('breaksConfig').style.display = 'none';
            document.getElementById('rebuysConfig').style.display = 'none';

            recalcAll();
        });


        function setupFormInteractions() {
            const useBreaks = document.getElementById('useBreaks');
            const breaksConfig = document.getElementById('breaksConfig');
            const allowRebuys = document.getElementById('allowRebuys');
            const rebuysConfig = document.getElementById('rebuysConfig');
            const speedSelect = document.getElementById('structureSpeed');
            const nameInput = document.getElementById('tournamentName');
            const generateBtn = document.getElementById('generateBtn');

            if (speedSelect) {
                speedSelect.addEventListener('change', recalcAll);
            }
            if (nameInput) {
                nameInput.addEventListener('input', recalcAll);
            }
            generateBtn.addEventListener('click', () => {
                const structure = calculateStructure();
                if (!structure) return;
                const styleSelect = document.getElementById('pdfStyle');
                const pdfStyle = styleSelect ? styleSelect.value : 'mobile';
                if (typeof gtag === 'function') {
                    gtag('event', 'generate_pdf', {
                        players: structure.players,
                        runtime_hours: structure.runtimeHours,
                        breaks_enabled: structure.useBreaks,
                        rebuys_enabled: structure.allowRebuys
                    });
                }
                console.log('Generating PDF style:', pdfStyle);
                generatePdf(structure, pdfStyle);
            });
            useBreaks.addEventListener('change', () => {
                breaksConfig.style.display = useBreaks.checked ? 'block' : 'none';
                recalcAll();
            });

            allowRebuys.addEventListener('change', () => {
                rebuysConfig.style.display = allowRebuys.checked ? 'block' : 'none';
                recalcAll();
            });

            ['players', 'runtimeHours', 'breakMinutes', 'breakFrequencyHours', 'rebuyCutoffHours'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', recalcAll);
                }
            });

            document.querySelectorAll('input[name="stackUsageMode"]').forEach(radio => {
                radio.addEventListener('change', recalcAll);
            });

            document.getElementById('decreaseValuesBtn').addEventListener('click', () => {
                valueScaleStep = Math.max(valueScaleStep - 1, -2); // limit how tiny it gets
                recalcAll();
            });

            document.getElementById('increaseValuesBtn').addEventListener('click', () => {
                valueScaleStep = Math.min(valueScaleStep + 1, 3); // limit how huge it gets
                recalcAll();
            });
        }

        function recalcAll() {
            recalcChipUsageAndStacks();
            const structure = calculateStructure();
            renderPreview(structure);
        }

        // --- Chip Setup UI ---
        function initChipColorsUI() {
            const chipColorsCountInput = document.getElementById('chipColorsCount');
            const container = document.getElementById('chipColorsContainer');

            function rebuildRows() {
                const count = clamp(parseInt(chipColorsCountInput.value || '0', 10), 1, 5);
                chipColorsCountInput.value = count;

                container.innerHTML = '';
                chipColorRows = [];

                for (let i = 0; i < count; i++) {
                    const row = document.createElement('div');
                    row.className = 'inline-row';
                    row.style.marginTop = '4px';
                    row.style.flexWrap = 'wrap';
                    row.style.gap = '6px';

                    const labelSpan = document.createElement('span');
                    labelSpan.textContent = `Color ${i + 1}:`;

                    const colorSelect = document.createElement('select');
                    COLOR_OPTIONS.forEach((color, idx) => {
                        const opt = document.createElement('option');
                        opt.value = color;
                        opt.textContent = color;
                        colorSelect.appendChild(opt);
                    });
                    colorSelect.selectedIndex = i < COLOR_OPTIONS.length ? i : 0;
                    colorSelect.style.width = '110px';

                    const countLabel = document.createElement('span');
                    countLabel.textContent = 'Total Available:';

                    const countInput = document.createElement('input');
                    countInput.type = 'number';
                    countInput.min = '0';
                    countInput.value = '50';
                    countInput.style.width = '80px';

                    row.appendChild(labelSpan);
                    row.appendChild(colorSelect);
                    row.appendChild(countLabel);
                    row.appendChild(countInput);
                    container.appendChild(row);

                    chipColorRows.push({ colorSelect, countInput });

                    colorSelect.addEventListener('change', recalcAll);
                    countInput.addEventListener('input', recalcAll);
                }

                recalcAll();
            }

            chipColorsCountInput.addEventListener('input', rebuildRows);
            rebuildRows();
        }

        function getColorCounts() {
            const colorCounts = {};
            COLOR_OPTIONS.forEach(c => { colorCounts[c] = 0; });

            chipColorRows.forEach(row => {
                const color = row.colorSelect.value;
                const count = parseInt(row.countInput.value || '0', 10);
                if (!isNaN(count) && count > 0) {
                    colorCounts[color] += count;
                }
            });

            // Build array of used colors
            const used = [];
            COLOR_OPTIONS.forEach(color => {
                const count = colorCounts[color];
                if (count > 0) {
                    used.push({ name: color, count });
                }
            });

            return { colorCounts, usedColors: used };
        }

        function computeColorValues(usedColors) {
            // Base patterns by number of colors (typical "feel"):
            const basePatterns = {
                1: [25],
                2: [25, 100],
                3: [25, 100],
                4: [25, 100, 500, 1000],
                5: [25, 100, 500, 1000, 5000]
            };

            const n = usedColors.length;
            if (n === 0) return {};

            // Pick a base pattern of the right length
            const base = (basePatterns[n] || basePatterns[5].slice(0, n)).slice();

            // Map valueScaleStep to **integer-friendly** multipliers
            // No weird decimals: always multiply, then round to nearest 5.
            const scaleMultipliers = {
                '-2': 0.25,
                '-1': 0.5,
                '0': 1,
                '1': 2,
                '2': 4,
                '3': 8
            };
            const multiplier = scaleMultipliers[String(valueScaleStep)] ?? 1;

            const map = {};
            for (let i = 0; i < n; i++) {
                const colorName = usedColors[i].name;
                const raw = base[i] * multiplier;

                // âœ… round to nearest 5, never < 5, and always an integer
                let rounded = Math.round(raw / 5) * 5;
                if (rounded < 5) rounded = 5;

                map[colorName] = rounded;
            }
            return map;
        }

        // --- Chip usage + suggested starting stack ---
        function recalcChipUsageAndStacks() {
            const playersInput = document.getElementById('players');
            const helper = document.getElementById('stackUsageHelper');
            const summaryNote = document.getElementById('chipSummaryNote');
            const valueScaleLabel = document.getElementById('valueScaleLabel');

            const players = clamp(parseInt(playersInput.value || '0', 10), 1, 50);

            const { usedColors } = getColorCounts();
            const totalChips = usedColors.reduce((sum, c) => sum + c.count, 0);

            if (totalChips === 0 || !players) {
                helper.textContent = 'Enter chip counts and number of players to see a suggested stack.';
                summaryNote.textContent = 'No chip counts or players yet.';
                valueScaleLabel.textContent = 'Current values will be shown here after you enter chip colors.';
                currentStackSuggestion = null;
                return;
            }

            // Values follow the color order: White < Red < Green < Blue < Black
            const valueMap = computeColorValues(usedColors);

            // How aggressively we use the total chip pool
            const modeRadio = document.querySelector('input[name="stackUsageMode"]:checked');
            const mode = modeRadio ? modeRadio.value : 'half';
            const usageFractions = { some: 0.25, half: 0.5, most: 0.75, max: 0.9 };
            const fraction = usageFractions[mode] || 0.5;

            let chipsForStacks = Math.floor(totalChips * fraction);
            const minNeeded = players * MIN_CHIPS_PER_PLAYER;

            if (chipsForStacks < minNeeded) {
                chipsForStacks = Math.min(minNeeded, totalChips);
            }
            if (chipsForStacks <= 0) {
                helper.textContent = 'Not enough chips to build a starting stack.';
                summaryNote.textContent = `Total available chips: ${totalChips}.`;
                currentStackSuggestion = null;
                return;
            }

            const chipsPerPlayer = Math.floor(chipsForStacks / players);
            if (chipsPerPlayer < MIN_CHIPS_PER_PLAYER) {
                helper.textContent =
                    `Not enough chips for ${players} players. ` +
                    `Try reducing players or increasing chip counts.`;
                summaryNote.textContent =
                    `Total available chips: ${totalChips}. ` +
                    `Even distribution would give only ${chipsPerPlayer} chips per player.`;
                currentStackSuggestion = null;
                return;
            }

            // Build per-color structure sorted by "smallest to largest" (White..Black)
            const perPlayer = usedColors
                .map(c => ({
                    name: c.name,
                    value: valueMap[c.name],
                    available: c.count,
                    perPlayerCount: 0,
                    maxPerPlayer: Math.floor(c.count / players),
                    rank: COLOR_OPTIONS.indexOf(c.name)
                }))
                .sort((a, b) => a.rank - b.rank);

            const N = perPlayer.length;

            // ðŸŽ¯ Weight lower denominations more heavily
            // For up to 5 colors, use weights â‰ˆ [6, 4, 2, 1, 1].
            const baseWeightsAll = [6, 4, 2, 1, 1];
            const weights = perPlayer.map((c, idx) => baseWeightsAll[idx] ?? 1);
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);

            // First pass: target chips per color based on weights,
            // but cap by inventory (maxPerPlayer).
            let assignedTotal = 0;
            for (let i = 0; i < N; i++) {
                const w = weights[i];
                const ideal = Math.floor((chipsPerPlayer * w) / totalWeight);
                const cap = perPlayer[i].maxPerPlayer;
                const given = Math.min(ideal, cap);
                perPlayer[i].perPlayerCount = given;
                assignedTotal += given;
            }

            // Second pass: distribute leftover chips, starting from the smallest value up,
            // still respecting inventory caps.
            let leftover = chipsPerPlayer - assignedTotal;
            while (leftover > 0) {
                let addedThisLoop = 0;
                for (let i = 0; i < N && leftover > 0; i++) {
                    if (perPlayer[i].perPlayerCount < perPlayer[i].maxPerPlayer) {
                        perPlayer[i].perPlayerCount += 1;
                        leftover -= 1;
                        addedThisLoop += 1;
                    }
                }
                if (addedThisLoop === 0) break; // inventory exhausted
            }

            const totalValuePerPlayer = perPlayer.reduce(
                (sum, c) => sum + c.perPlayerCount * c.value,
                0
            );

            helper.textContent =
                `You have ${totalChips} chips across ${N} colors. Mode â€œ${mode}â€ uses about ` +
                `${chipsPerPlayer * players} chips total (~${chipsPerPlayer} per player).`;

            const valuePairs = perPlayer.map(c => `${c.name} = ${c.value}`).join(', ');
            valueScaleLabel.textContent = `Current chip values: ${valuePairs}`;

            summaryNote.textContent =
                `Suggested starting stack: ~${chipsPerPlayer} chips per player, ` +
                `worth about ${totalValuePerPlayer.toLocaleString()} in chip value.`;

            currentStackSuggestion = {
                chipsPerPlayer,
                totalValuePerPlayer,
                colors: perPlayer
            };
        }

        function calculateStructure() {
            const errorBox = document.getElementById('errorBox');
            errorBox.style.display = 'none';
            errorBox.textContent = '';
            const nameEl = document.getElementById('tournamentName');
            const tournamentName = (nameEl ? nameEl.value.trim() : '') || 'Home Poker Tournament';
            const players = clamp(parseInt(document.getElementById('players').value || '0', 10), 1, 50);
            const runtimeHours = Math.max(0, parseFloat(document.getElementById('runtimeHours').value || '0'));

            if (!players || runtimeHours <= 0) {
                errorBox.style.display = 'block';
                errorBox.textContent = 'Please enter a valid number of players and runtime.';
                return null;
            }

            const useBreaks = document.getElementById('useBreaks').checked;
            const allowRebuys = document.getElementById('allowRebuys').checked;

            // --- Breaks & effective play time ---
            let breakMinutes = 0;
            let breakFrequencyHours = 0;
            let breaks = [];

            if (useBreaks) {
                breakMinutes = Math.max(0, parseInt(document.getElementById('breakMinutes').value || '0', 10));
                breakFrequencyHours = Math.max(0.25, parseFloat(document.getElementById('breakFrequencyHours').value || '0'));
                if (breakMinutes > 0) {
                    let t = breakFrequencyHours;
                    while (t < runtimeHours) {
                        breaks.push({ atHour: t, minutes: breakMinutes });
                        t += breakFrequencyHours;
                    }
                }
            }

            const totalBreakMinutes = breaks.reduce((sum, b) => sum + b.minutes, 0);
            let effectiveMinutes = runtimeHours * 60 - totalBreakMinutes;
            if (effectiveMinutes < 60) effectiveMinutes = 60;

            // --- Level length & count ---
            const levelMinutes = 12;
            let levelsCount = Math.floor(effectiveMinutes / levelMinutes);
            if (levelsCount < 4) levelsCount = 4; // at least a few levels

            // --- Starting stack value (per player) ---
            let startingStackValue = 8000;
            if (currentStackSuggestion && currentStackSuggestion.totalValuePerPlayer > 0) {
                startingStackValue = currentStackSuggestion.totalValuePerPlayer;
            }

            // --- Smallest chip value (for unit multiples) ---
            let chipValues = [];
            if (currentStackSuggestion && currentStackSuggestion.colors.length) {
                chipValues = currentStackSuggestion.colors.map(c => c.value);
            } else {
                chipValues = [25, 100, 500, 1000]; // generic fallback
            }
            const minChip = chipValues.length ? Math.min(...chipValues) : 25;

            // --- Option C: dynamic exponential blind curve ---
            // Start big blind at 2Ã— smallest chip
            let startBBRaw = minChip * 2;

            // Pick target depth of average stack at the final level based on speed
            const speedEl = document.getElementById('structureSpeed');
            const speed = speedEl ? speedEl.value : 'normal';
            let targetAvgBBAtEnd;

            if (speed === 'slow') {
                targetAvgBBAtEnd = 16;  // slower blind growth, deeper average stack
            } else if (speed === 'turbo') {
                targetAvgBBAtEnd = 8;   // faster blind growth, shallower avg stack
            } else {
                targetAvgBBAtEnd = 12;  // normal
            }

            let endBBRaw = startingStackValue / targetAvgBBAtEnd;


            // Make sure we actually grow (in case stack is tiny)
            if (endBBRaw < startBBRaw * 2) {
                endBBRaw = startBBRaw * 2;
            }

            let growthFactor = 1;
            if (levelsCount > 1) {
                growthFactor = Math.pow(endBBRaw / startBBRaw, 1 / (levelsCount - 1));
            }

            const schedule = [];
            let elapsed = 0;

            for (let i = 0; i < levelsCount; i++) {
                const level = i + 1;
                const levelStartMin = elapsed;
                const levelEndMin = elapsed + levelMinutes;

                // Raw BB for this level, then snap to chip units
                const bbRaw = startBBRaw * Math.pow(growthFactor, i);
                let bb = roundToUnit(bbRaw, minChip);
                let sb = roundToUnit(bb / 2, minChip);
                if (sb < minChip) sb = minChip;

                schedule.push({
                    level,
                    startMin: levelStartMin,
                    endMin: levelEndMin,
                    sb,
                    bb
                });

                elapsed += levelMinutes;
            }

            // --- Rebuy cutoff ---
            let rebuyCutoffHours = null;
            if (allowRebuys) {
                rebuyCutoffHours = Math.min(
                    runtimeHours,
                    Math.max(0.5, parseFloat(document.getElementById('rebuyCutoffHours').value || '0'))
                );
            }

            return {
                players,
                runtimeHours,
                useBreaks,
                breakMinutes,
                breakFrequencyHours,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                levelsCount,
                levelMinutes,
                schedule,
                startingStackValue,
                tournamentName
            };
        }

        function buildDisplaySchedule(structure) {
            const baseSchedule = structure.schedule || [];
            const breaks = structure.breaks || [];
            const allowRebuys = structure.allowRebuys;
            const rebuyCutoffHours = structure.rebuyCutoffHours;

            // Start with just the levels
            const rows = baseSchedule.map(l => ({
                type: 'level',
                level: l.level,
                startMin: l.startMin,
                endMin: l.endMin,
                sb: l.sb,
                bb: l.bb,
                note: ''
            }));

            // Attach breaks: place each break after the level whose midpoint
            // is closest to the requested break time.
            breaks.forEach(b => {
                const targetMinutes = b.atHour * 60;
                let closestIndex = 0;
                let bestDiff = Infinity;

                rows.forEach((r, idx) => {
                    if (r.type !== 'level') return;
                    const mid = (r.startMin + r.endMin) / 2;
                    const diff = Math.abs(mid - targetMinutes);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        closestIndex = idx;
                    }
                });

                // Insert a break row after that level
                rows.splice(closestIndex + 1, 0, {
                    type: 'break',
                    level: null,
                    startMin: null,
                    endMin: null,
                    sb: null,
                    bb: null,
                    note: `Break (${b.minutes} min)`
                });
            });

            // Attach rebuy cutoff note on the level whose midpoint is
            // closest to the rebuy cutoff hour.
            if (allowRebuys && rebuyCutoffHours) {
                const cutoffMinutes = rebuyCutoffHours * 60;
                let cutoffIdx = 0;
                let bestDiff = Infinity;

                rows.forEach((r, idx) => {
                    if (r.type !== 'level') return;
                    const mid = (r.startMin + r.endMin) / 2;
                    const diff = Math.abs(mid - cutoffMinutes);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        cutoffIdx = idx;
                    }
                });

                const r = rows[cutoffIdx];
                r.note += (r.note ? ' ' : '') + 'Rebuys end after this level.';
            }

            return rows;
        }

        // --- Preview rendering ---
        function renderPreview(structure) {
            const container = document.getElementById('previewContent');

            if (!structure) {
                container.innerHTML = '<p class="small-note muted">Fix errors on the left to see the preview.</p>';
                return;
            }

            const {
                players,
                runtimeHours,
                useBreaks,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                schedule,
                levelMinutes,
                startingStackValue,
                tournamentName
            } = structure;

            const runtimeStr = runtimeHours.toFixed(1).replace(/\.0$/, '');
            const metaHtml = `
        <div class="preview-section-title">Tournament Summary</div>
        <table>
          <tbody>
            <tr><td>Name</td><td>${tournamentName}</td></tr>
            <tr><td>Players</td><td>${players}</td></tr>
            <tr><td>Runtime</td><td>${runtimeStr} hours</td></tr>
            <tr><td>Level length</td><td>${levelMinutes} minutes</td></tr>
            <tr><td>Starting stack value</td><td>${startingStackValue.toLocaleString()}</td></tr>
          </tbody>
        </table>
      `;

            let startingStackHtml = '';
            if (currentStackSuggestion) {
                const stack = currentStackSuggestion;
                const rowsHtml = stack.colors
                    .filter(c => c.perPlayerCount > 0)
                    .map(c => {
                        const totalUsed = c.perPlayerCount * structure.players;
                        return `
              <tr>
                <td>${c.name}</td>
                <td>${c.value}</td>
                <td>${c.perPlayerCount}</td>
                <td>${totalUsed}</td>
              </tr>`;
                    })
                    .join('');

                startingStackHtml = `
          <div class="preview-section-title">Suggested Starting Stack (per player)</div>
          <span class="small-note">
            Approx. ${stack.chipsPerPlayer} chips per player, total value ~${stack.totalValuePerPlayer.toLocaleString()}.
          </span>
          <div class="scroll-box">
            <table>
              <thead>
                <tr>
                  <th>Color</th>
                  <th>Value</th>
                  <th>Chips / Player</th>
                  <th>Total Used</th>
                </tr>
              </thead>
              <tbody>${rowsHtml}</tbody>
            </table>
          </div>
        `;
            } else {
                startingStackHtml = `
          <div class="preview-section-title">Suggested Starting Stack (per player)</div>
          <span class="small-note muted">
            Define chip colors and counts to see a suggested stack.
          </span>
        `;
            }

            let breaksHtml = '';
            if (useBreaks && breaks.length) {
                const rows = breaks.map((b, idx) => {
                    const atMin = Math.round(b.atHour * 60);
                    return `<tr><td>Break ${idx + 1}</td><td>${b.minutes} min</td><td>${formatMinutes(atMin)}</td></tr>`;
                }).join('');
                breaksHtml = `
          <div class="preview-section-title">Breaks</div>
          <div class="scroll-box">
            <table>
              <thead>
                <tr><th>#</th><th>Length</th><th>Approx. Time</th></tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
          <span class="small-note">
            Total break time: ${totalBreakMinutes} minutes.
          </span>
        `;
            } else {
                breaksHtml = `
          <div class="preview-section-title">Breaks</div>
          <span class="small-note muted">
            No scheduled breaks, or break config not enabled.
          </span>
        `;
            }

            let rebuysHtml = '';
            if (allowRebuys && rebuyCutoffHours) {
                rebuysHtml = `
          <div class="preview-section-title">Rebuys</div>
          <span class="small-note">
            Rebuys allowed until ${rebuyCutoffHours.toFixed(1).replace(/\.0$/, '')} hours after start.
            Each rebuy uses the same stack as the initial buy-in.
          </span>
        `;
            } else {
                rebuysHtml = `
          <div class="preview-section-title">Rebuys</div>
          <span class="small-note muted">
            Rebuys disabled.
          </span>
        `;
            }

            const displayRows = buildDisplaySchedule(structure);

            const scheduleRows = displayRows.map(r => {
                if (r.type === 'level') {
                    return `
                  <tr>
                    <td>${r.level}</td>
                    <td>${formatMinutes(r.startMin)}</td>
                    <td>${formatMinutes(r.endMin)}</td>
                    <td>${r.sb}</td>
                    <td>${r.bb}</td>
                    <td>${r.note || ''}</td>
                  </tr>
                `;
                } else {
                    // break row
                    return `
                  <tr>
                    <td>â€”</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>${r.note || 'Break'}</td>
                  </tr>
                `;
                }
            }).join('');

            const scheduleHtml = `
              <div class="preview-section-title">Blind Schedule</div>
              <div class="scroll-box">
                <table>
                  <thead>
                    <tr>
                      <th>Lvl</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>SB</th>
                      <th>BB</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>${scheduleRows}</tbody>
                </table>
              </div>
            `;


            container.innerHTML = `
        ${metaHtml}
        ${startingStackHtml}
        ${breaksHtml}
        ${rebuysHtml}
        ${scheduleHtml}
      `;
        }

        function formatMinutes(min) {
            const h = Math.floor(min / 60);
            const m = min % 60;
            const hStr = h === 0 ? '0' : h.toString();
            const mStr = m.toString().padStart(2, '0');
            return `${hStr}:${mStr}`;
        }

    functionÂ generatePdf(structure,Â pdfStyle)Â {
Â Â  
Â Â Â Â  ifÂ (!window.jspdfÂ ||Â !window.jspdf.jsPDF)Â {
Â Â Â Â  
Â Â Â Â Â Â  alert('PDFÂ engineÂ (jsPDF)Â didÂ notÂ load.Â CheckÂ yourÂ connectionÂ andÂ tryÂ again.');
Â Â Â Â  
Â Â Â Â Â Â  return;
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  constÂ {Â jsPDFÂ }Â =Â window.jspdf;
Â Â  
Â Â Â Â  constÂ isMobileStyleÂ =Â pdfStyleÂ ===Â 'mobile';
Â Â  
Â Â Â Â  constÂ docÂ =Â newÂ jsPDF({Â unit:Â 'mm',Â format:Â 'a4'Â });

Â Â Â Â Â constÂ {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â players,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â runtimeHours,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â useBreaks,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â breaks,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â totalBreakMinutes,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â allowRebuys,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â rebuyCutoffHours,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â startingStackValue,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â levelMinutes,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â tournamentName

Â Â Â Â Â }Â =Â structure;
Â Â Â Â  
Â Â Â Â Â constÂ pageWidthÂ =Â doc.internal.pageSize.getWidth();
Â Â  
Â Â Â Â  constÂ pageHeightÂ =Â doc.internal.pageSize.getHeight();
Â Â  
Â Â Â Â  constÂ marginXÂ =Â 14;
Â Â  
Â Â Â Â  constÂ contentWidthÂ =Â pageWidthÂ -Â marginXÂ *Â 2;
Â Â  
Â Â Â Â  constÂ runtimeStrÂ =Â runtimeHours.toFixed(1).replace(/\.0$/,Â '');
Â Â  
Â Â Â Â  //Â ColorÂ palettes
Â Â  
Â Â Â Â  constÂ darkÂ =Â {
Â Â Â Â  
Â Â Â Â Â Â  bg:Â [3,Â 7,Â 30],
Â Â Â Â  
Â Â Â Â Â Â  cardBg:Â [15,Â 23,Â 42],
Â Â Â Â  
Â Â Â Â Â Â  textMain:Â [241,Â 245,Â 249],
Â Â Â Â  
Â Â Â Â Â Â  textMuted:Â [156,Â 163,Â 175],
Â Â Â Â  
Â Â Â Â Â Â  accent:Â [34,Â 197,Â 94],
Â Â Â Â  
Â Â Â Â Â Â  border:Â [51,Â 65,Â 85],
Â Â Â Â  
Â Â Â Â Â Â  tableBase:Â [15,Â 23,Â 42],
Â Â Â Â  
Â Â Â Â Â Â  tableAlt:Â [30,Â 41,Â 59]
Â Â Â Â  
Â Â Â Â Â };
Â Â  
Â Â Â Â  constÂ lightÂ =Â {
Â Â Â Â  
Â Â Â Â Â Â  bg:Â [255,Â 255,Â 255],
Â Â Â Â  
Â Â Â Â Â Â  cardBg:Â [248,Â 250,Â 252],
Â Â Â Â  
Â Â Â Â Â Â  textMain:Â [15,Â 23,Â 42],
Â Â Â Â  
Â Â Â Â Â Â  textMuted:Â [100,Â 116,Â 139],
Â Â Â Â  
Â Â Â Â Â Â  accent:Â [34,Â 197,Â 94],
Â Â Â Â  
Â Â Â Â Â Â  border:Â [226,Â 232,Â 240],
Â Â Â Â  
Â Â Â Â Â Â  tableBase:Â [255,Â 255,Â 255],
Â Â Â Â  
Â Â Â Â Â Â  tableAlt:Â [241,Â 245,Â 249]
Â Â Â Â  
Â Â Â Â Â };
Â Â  
Â Â Â Â  constÂ pÂ =Â isMobileStyleÂ ?Â darkÂ :Â light;
Â Â  
Â Â Â Â  functionÂ paintBackground()Â {
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFillColor(...p.bg);
Â Â Â Â  
Â Â Â Â Â Â Â doc.rect(0,Â 0,Â pageWidth,Â pageHeight,Â 'F');
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  paintBackground();
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â  
Â Â Â Â  //Â ----------------Â PAGEÂ 1Â ----------------
Â Â  
Â Â Â Â  letÂ yÂ =Â 22;
Â Â  
Â Â Â Â  //Â Title
Â Â  
Â Â Â Â Â doc.setTextColor(...p.accent);
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â  
Â Â Â Â Â doc.setFontSize(24);
Â Â  
Â Â Â Â Â doc.text(tournamentNameÂ ||Â 'HomeÂ PokerÂ Tournament',Â pageWidthÂ /Â 2,Â y,Â {
Â Â Â Â  
Â Â Â Â Â Â  align:Â 'center'
Â Â Â Â  
Â Â Â Â Â });
Â Â  
Â Â Â Â Â yÂ +=Â 8;
Â Â  
Â Â Â Â  //Â Subtitle
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â  
Â Â Â Â Â doc.setFontSize(11);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.textMuted);
Â Â  
Â Â Â Â Â doc.text(
Â Â Â Â  
Â Â Â Â Â Â  `PokerÂ TournamentÂ GuideÂ â€¢Â ${players}Â playersÂ â€¢Â ~${runtimeStr}Â hours`,
Â Â Â Â  
Â Â Â Â Â Â Â pageWidthÂ /Â 2,
Â Â Â Â  
Â Â Â Â Â Â Â y,
Â Â Â Â  
Â Â Â Â Â Â Â {Â align:Â 'center'Â }
Â Â Â Â  
Â Â Â Â Â );
Â Â  
Â Â Â Â Â yÂ +=Â 6;
Â Â  
Â Â Â Â  //Â SmallÂ greenÂ pillÂ underÂ title
Â Â  
Â Â Â Â  constÂ pillTextÂ =Â 'BlindsÂ â€¢Â StackÂ â€¢Â Breaks';
Â Â  
Â Â Â Â  constÂ pillWidthÂ =Â doc.getTextWidth(pillText)Â +Â 10;
Â Â  
Â Â Â Â  constÂ pillXÂ =Â (pageWidthÂ -Â pillWidth)Â /Â 2;
Â Â  
Â Â Â Â  constÂ pillYÂ =Â yÂ -Â 4;
Â Â  
Â Â Â Â Â doc.setFillColor(...p.accent);
Â Â  
Â Â Â Â Â doc.roundedRect(pillX,Â pillY,Â pillWidth,Â 7,Â 3,Â 3,Â 'F');
Â Â  
Â Â Â Â Â doc.setFontSize(9);
Â Â  
Â Â Â Â Â doc.setTextColor(2,Â 6,Â 23);
Â Â  
Â Â Â Â Â doc.text(pillText,Â pageWidthÂ /Â 2,Â yÂ +Â 1,Â {Â align:Â 'center'Â });
Â Â  
Â Â Â Â Â yÂ +=Â 9;
Â Â  
Â Â Â Â  //Â AccentÂ line
Â Â  
Â Â Â Â Â doc.setDrawColor(...p.accent);
Â Â  
Â Â Â Â Â doc.setLineWidth(0.6);
Â Â  
Â Â Â Â Â doc.line(marginX,Â y,Â pageWidthÂ -Â marginX,Â y);
Â Â  
Â Â Â Â Â yÂ +=Â 8;
Â Â  
Â Â Â Â  //Â =====Â TournamentÂ SummaryÂ headerÂ (centered)Â =====
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â  
Â Â Â Â Â doc.setFontSize(15);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.accent);
Â Â  
Â Â Â Â Â doc.text('TournamentÂ Summary',Â pageWidthÂ /Â 2,Â y,Â {Â align:Â 'center'Â });
Â Â  
Â Â Â Â Â yÂ +=Â 5;
Â Â  
Â Â Â Â  //Â SummaryÂ card
Â Â  
Â Â Â Â  constÂ cardTopÂ =Â y;
Â Â  
Â Â Â Â  constÂ cardPaddingYÂ =Â 6;
Â Â  
Â Â Â Â  constÂ colGapÂ =Â 8;
Â Â  
Â Â Â Â  constÂ leftColXÂ =Â marginXÂ +Â 5;
Â Â  
Â Â Â Â  constÂ rightColXÂ =Â pageWidthÂ /Â 2Â +Â 5;
Â Â  
Â Â Â Â  //Â BuildÂ textÂ forÂ left/rightÂ columns
Â Â  
Â Â Â Â  constÂ leftLinesÂ =Â [
Â Â Â Â  
Â Â Â Â Â Â  `Name:Â ${tournamentNameÂ ||Â 'HomeÂ PokerÂ Tournament'}`,
Â Â Â Â  
Â Â Â Â Â Â  `Players:Â ${players}`,
Â Â Â Â  
Â Â Â Â Â Â  `Runtime:Â ${runtimeStr}Â hoursÂ (includesÂ breaks)`,
Â Â Â Â  
Â Â Â Â Â Â  `LevelÂ length:Â ${levelMinutes}Â minutes`,
Â Â Â Â  
Â Â Â Â Â Â  `StartingÂ stackÂ value:Â ${startingStackValue.toLocaleString()}`
Â Â Â Â  
Â Â Â Â Â ];
Â Â  
Â Â Â Â  ifÂ (useBreaksÂ &&Â breaks.length)Â {
Â Â Â Â  
Â Â Â Â Â Â Â leftLines.push(`TotalÂ breakÂ time:Â ${totalBreakMinutes}Â minutes`);
Â Â Â Â  
Â Â Â Â Â }Â elseÂ {
Â Â Â Â  
Â Â Â Â Â Â Â leftLines.push('Breaks:Â noneÂ scheduled');
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  ifÂ (allowRebuysÂ &&Â rebuyCutoffHours)Â {
Â Â Â Â  
Â Â Â Â Â Â Â leftLines.push(
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  `Rebuys:Â allowedÂ untilÂ ${rebuyCutoffHours
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â .toFixed(1)
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â .replace(/\.0$/,Â '')}Â hours`
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â );
Â Â Â Â  
Â Â Â Â Â }Â elseÂ {
Â Â Â Â  
Â Â Â Â Â Â Â leftLines.push('Rebuys:Â notÂ allowed');
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  constÂ rightLinesÂ =Â [];
Â Â  
Â Â Â Â  ifÂ (
Â Â Â Â  
Â Â Â Â Â Â  window.currentStackSuggestionÂ &&
Â Â Â Â  
Â Â Â Â Â Â Â currentStackSuggestion.colors.some(cÂ =>Â c.perPlayerCountÂ >Â 0)
Â Â Â Â  
Â Â Â Â Â )Â {
Â Â Â Â  
Â Â Â Â Â Â Â rightLines.push('StartingÂ stackÂ breakdown:');
Â Â Â Â  
Â Â Â Â Â Â Â currentStackSuggestion.colors
Â Â Â Â  
Â Â Â Â Â Â Â Â Â .filter(cÂ =>Â c.perPlayerCountÂ >Â 0)
Â Â Â Â  
Â Â Â Â Â Â Â Â Â .forEach(cÂ =>Â {
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â rightLines.push(
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  `${c.perPlayerCount}Â Ã—Â ${c.name}Â (${c.value})`
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  constÂ lineHÂ =Â 5;
Â Â  
Â Â Â Â  constÂ leftHeightÂ =Â leftLines.lengthÂ *Â lineH;
Â Â  
Â Â Â Â  constÂ rightHeightÂ =Â rightLines.lengthÂ *Â lineH;
Â Â  
Â Â Â Â  constÂ cardContentHeightÂ =Â Math.max(leftHeight,Â rightHeight);
Â Â  
Â Â Â Â  constÂ cardHeightÂ =Â cardPaddingYÂ *Â 2Â +Â cardContentHeight;
Â Â  
Â Â Â Â  //Â CardÂ background
Â Â  
Â Â Â Â Â doc.setDrawColor(...p.border);
Â Â  
Â Â Â Â  ifÂ (isMobileStyle)Â {
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFillColor(...p.cardBg);
Â Â Â Â  
Â Â Â Â Â Â Â doc.roundedRect(
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â marginXÂ -Â 1,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â cardTopÂ -Â 4,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â contentWidthÂ +Â 2,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â cardHeightÂ +Â 8,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  4,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  4,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  'FD'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â );
Â Â Â Â  
Â Â Â Â Â }Â elseÂ {
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFillColor(...p.cardBg);
Â Â Â Â  
Â Â Â Â Â Â Â doc.roundedRect(
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â marginXÂ -Â 1,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â cardTopÂ -Â 4,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â contentWidthÂ +Â 2,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â cardHeightÂ +Â 8,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  4,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  4,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  'FD'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â );
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  //Â LeftÂ columnÂ text
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â  
Â Â Â Â Â doc.setFontSize(11);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.textMain);
Â Â  
Â Â Â Â  letÂ textYÂ =Â cardTopÂ +Â cardPaddingY;
Â Â  
Â Â Â Â Â leftLines.forEach(lineÂ =>Â {
Â Â Â Â  
Â Â Â Â Â Â Â doc.text(line,Â leftColX,Â textY);
Â Â Â Â  
Â Â Â Â Â Â Â textYÂ +=Â lineH;
Â Â Â Â  
Â Â Â Â Â });
Â Â  
Â Â Â Â  //Â RightÂ columnÂ text
Â Â  
Â Â Â Â Â textYÂ =Â cardTopÂ +Â cardPaddingY;
Â Â  
Â Â Â Â Â rightLines.forEach((line,Â idx)Â =>Â {
Â Â Â Â  
Â Â Â Â Â Â  ifÂ (idxÂ ===Â 0)Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â Â Â Â Â  
Â Â Â Â Â Â Â }Â elseÂ {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â Â Â Â Â  
Â Â Â Â Â Â Â }
Â Â Â Â  
Â Â Â Â Â Â Â doc.text(line,Â rightColX,Â textY);
Â Â Â Â  
Â Â Â Â Â Â Â textYÂ +=Â lineH;
Â Â Â Â  
Â Â Â Â Â });
Â Â  
Â Â Â Â Â yÂ =Â cardTopÂ +Â cardHeightÂ +Â 12;
//Â =====Â HandÂ RankingsÂ headerÂ (centered,Â green)Â =====
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â  
Â Â Â Â Â doc.setFontSize(15);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.accent);
Â Â  
Â Â Â Â Â doc.text(
Â Â Â Â  
Â Â Â Â Â Â  'HandÂ RankingsÂ (StrongestÂ toÂ Weakest)',
Â Â Â Â  
Â Â Â Â Â Â Â pageWidthÂ /Â 2,
Â Â Â Â  
Â Â Â Â Â Â Â y,
Â Â Â Â  
Â Â Â Â Â Â Â {Â align:Â 'center'Â }
Â Â Â Â  
Â Â Â Â Â );
Â Â  
Â Â Â Â Â yÂ +=Â 6;
Â Â  
Â Â Â Â  //Â HandÂ rankingÂ blocks
Â Â  
Â Â Â Â Â doc.setTextColor(...p.textMain);
Â Â  
Â Â Â Â  constÂ handsÂ =Â [
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'ROYALÂ FLUSH',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â 'A,Â K,Â Q,Â J,Â 10Â â€”Â allÂ ofÂ theÂ sameÂ suit.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'STRAIGHTÂ FLUSH',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '5Â cardsÂ ofÂ theÂ sameÂ suitÂ inÂ sequence.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'FOURÂ OFÂ AÂ KIND',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '4Â cardsÂ ofÂ equalÂ value.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'FULLÂ HOUSE',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â 'ThreeÂ ofÂ aÂ kindÂ withÂ aÂ pair.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'FLUSH',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â 'AnyÂ 5Â cardsÂ ofÂ theÂ sameÂ suit.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'STRAIGHT',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '5Â cardsÂ inÂ aÂ sequence.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'THREEÂ OFÂ AÂ KIND',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '3Â cardsÂ ofÂ theÂ sameÂ value.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'TWOÂ PAIRS',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '2Â differentÂ pairs.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'ONEÂ PAIR',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '2Â cardsÂ ofÂ theÂ sameÂ value.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â },
Â Â Â Â  
Â Â Â Â Â Â Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  title:Â 'HIGHÂ CARD',
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  desc:Â '5Â cardsÂ thatÂ donâ€™tÂ interactÂ withÂ eachÂ other.'
Â Â Â Â Â Â  
Â Â Â Â Â Â Â }
Â Â Â Â  
Â Â Â Â Â ];
Â Â  
Â Â Â Â Â doc.setFontSize(11);
Â Â  
Â Â Â Â  constÂ blockHeightÂ =Â (pageHeightÂ -Â yÂ -Â 18)Â /Â hands.length;Â //Â evenlyÂ fillÂ page
Â Â  
Â Â Â Â Â hands.forEach((hand,Â idx)Â =>Â {
Â Â Â Â  
Â Â Â Â Â Â  constÂ blockTopÂ =Â yÂ +Â idxÂ *Â blockHeight;
Â Â Â Â  
Â Â Â Â Â Â  constÂ blockInnerTopÂ =Â blockTopÂ +Â 2;
Â Â Â Â  
Â Â Â Â Â Â  constÂ blockBottomÂ =Â blockTopÂ +Â blockHeight;
Â Â Â Â  
Â Â Â Â Â Â  //Â Title
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â Â Â  
Â Â Â Â Â Â Â doc.text(hand.title,Â marginX,Â blockInnerTopÂ +Â 4);
Â Â Â Â  
Â Â Â Â Â Â  //Â Description
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â Â Â  
Â Â Â Â Â Â Â doc.setTextColor(...p.textMuted);
Â Â Â Â  
Â Â Â Â Â Â  constÂ wrappedÂ =Â doc.splitTextToSize(hand.desc,Â contentWidthÂ *Â 0.6);
Â Â Â Â  
Â Â Â Â Â Â Â doc.text(wrapped,Â marginX,Â blockInnerTopÂ +Â 10);
Â Â Â Â  
Â Â Â Â Â Â  //Â DividerÂ lineÂ acrossÂ blockÂ bottomÂ (exceptÂ last)
Â Â Â Â  
Â Â Â Â Â Â  ifÂ (idxÂ <Â hands.lengthÂ -Â 1)Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.setDrawColor(...p.border);
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.setLineWidth(0.3);
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.line(
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â marginX,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â blockBottomÂ -Â 2,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â pageWidthÂ -Â marginX,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â blockBottomÂ -Â 2
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â  
Â Â Â Â Â Â Â }
Â Â Â Â  
Â Â Â Â Â Â  //Â ResetÂ colorÂ forÂ nextÂ blockÂ title
Â Â Â Â  
Â Â Â Â Â Â Â doc.setTextColor(...p.textMain);
Â Â Â Â  
Â Â Â Â Â });
Â Â  
Â Â Â Â  //Â ----------------Â PAGEÂ 2Â ----------------
Â Â  
Â Â Â Â Â doc.addPage();
Â Â  
Â Â Â Â  paintBackground();
Â Â  
Â Â Â Â Â yÂ =Â 20;
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â  
Â Â Â Â Â doc.setFontSize(16);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.textMain);
Â Â  
Â Â Â Â Â doc.text('StructureÂ Overview',Â marginX,Â y);
Â Â  
Â Â Â Â Â yÂ +=Â 4;
Â Â  
Â Â Â Â Â doc.setDrawColor(...p.accent);
Â Â  
Â Â Â Â Â doc.setLineWidth(0.6);
Â Â  
Â Â Â Â Â doc.line(marginX,Â y,Â marginXÂ +Â 38,Â y);
Â Â  
Â Â Â Â Â yÂ +=Â 8;
Â Â  
Â Â Â Â  //Â SuggestedÂ stackÂ table
Â Â  
Â Â Â Â  ifÂ (
Â Â Â Â  
Â Â Â Â Â Â  window.currentStackSuggestionÂ &&
Â Â Â Â  
Â Â Â Â Â Â Â currentStackSuggestion.colors.some(cÂ =>Â c.perPlayerCountÂ >Â 0)
Â Â Â Â  
Â Â Â Â Â )Â {
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFontSize(13);
Â Â Â Â  
Â Â Â Â Â Â Â doc.setTextColor(...p.accent);
Â Â Â Â  
Â Â Â Â Â Â Â doc.text('SuggestedÂ StartingÂ StackÂ (perÂ player)',Â marginX,Â y);
Â Â Â Â  
Â Â Â Â Â Â Â yÂ +=Â 5;
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â Â Â  
Â Â Â Â Â Â Â doc.setFontSize(10);
Â Â Â Â  
Â Â Â Â Â Â Â doc.setTextColor(...p.textMuted);
Â Â Â Â  
Â Â Â Â Â Â Â doc.text(
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  `Approx.Â ${currentStackSuggestion.chipsPerPlayer}Â chipsÂ perÂ player,Â valueÂ ~${currentStackSuggestion.totalValuePerPlayer.toLocaleString()}.`,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â marginX,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â y
Â Â Â Â Â Â  
Â Â Â Â Â Â Â );
Â Â Â Â  
Â Â Â Â Â Â Â yÂ +=Â 4;
Â Â Â Â  
Â Â Â Â Â Â  ifÂ (doc.autoTable)Â {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  constÂ startYÂ =Â yÂ +Â 2;
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.autoTable({
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â startY,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  head:Â [['Color',Â 'Value',Â 'ChipsÂ /Â Player',Â 'TotalÂ Used']],
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  body:Â currentStackSuggestion.colors
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â .filter(cÂ =>Â c.perPlayerCountÂ >Â 0)
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â .map(cÂ =>Â [
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â c.name,
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String(c.value),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String(c.perPlayerCount),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String(c.perPlayerCountÂ *Â players)
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â ]),
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  styles:Â {
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  fontSize:Â 9.2,
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  textColor:Â isMobileStyleÂ ?Â [248,Â 250,Â 252]Â :Â p.textMain,
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  fillColor:Â isMobileStyleÂ ?Â p.tableBaseÂ :Â p.tableBase
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  headStyles:Â {
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  fillColor:Â p.accent,
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  textColor:Â [2,Â 6,Â 23]
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  alternateRowStyles:Â {
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  fillColor:Â isMobileStyleÂ ?Â p.tableAltÂ :Â p.tableAlt
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  margin:Â {Â left:Â marginX,Â right:Â marginXÂ }
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  constÂ tableBottomÂ =Â doc.lastAutoTable.finalY;
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.setDrawColor(...p.border);
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.setFillColor(...p.cardBg);
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â doc.roundedRect(
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â marginXÂ -Â 1,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â startYÂ -Â 3,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â contentWidthÂ +Â 2,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â tableBottomÂ -Â startYÂ +Â 6,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  3,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  3
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â yÂ =Â tableBottomÂ +Â 12;
Â Â Â Â Â Â  
Â Â Â Â Â Â Â }Â elseÂ {
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â yÂ +=Â 10;
Â Â Â Â Â Â  
Â Â Â Â Â Â Â }
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  //Â BlindÂ schedule
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'bold');
Â Â  
Â Â Â Â Â doc.setFontSize(13);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.accent);
Â Â  
Â Â Â Â Â doc.text('BlindÂ Schedule',Â marginX,Â y);
Â Â  
Â Â Â Â Â yÂ +=Â 5;
Â Â  
Â Â Â Â  ifÂ (doc.autoTable)Â {
Â Â Â Â  
Â Â Â Â Â Â  constÂ displayRowsÂ =Â buildDisplaySchedule(structure);
Â Â Â Â  
Â Â Â Â Â Â Â doc.autoTable({
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  startY:Â yÂ +Â 2,
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  head:Â [['Lvl',Â 'Start',Â 'End',Â 'SB',Â 'BB',Â 'Note']],
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  body:Â displayRows.map(rÂ =>Â {
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  ifÂ (r.typeÂ ===Â 'level')Â {
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  returnÂ [
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String(r.level),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  formatMinutes(r.startMin),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  formatMinutes(r.endMin),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String(r.sb),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String(r.bb),
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â r.noteÂ ||Â ''
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â ];
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â }Â elseÂ {
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  returnÂ ['â€”',Â '',Â '',Â '',Â '',Â r.noteÂ ||Â 'Break'];
Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â }),
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  styles:Â {
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  fontSize:Â 9.2,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  textColor:Â isMobileStyleÂ ?Â [248,Â 250,Â 252]Â :Â p.textMain,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  fillColor:Â isMobileStyleÂ ?Â p.tableBaseÂ :Â p.tableBase
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  headStyles:Â {
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  fillColor:Â p.accent,
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  textColor:Â [2,Â 6,Â 23]
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  alternateRowStyles:Â {
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â  fillColor:Â isMobileStyleÂ ?Â p.tableAltÂ :Â p.tableAlt
Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â  margin:Â {Â left:Â marginX,Â right:Â marginXÂ }
Â Â Â Â Â Â  
Â Â Â Â Â Â Â });
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â Â  //Â Footer
Â Â  
Â Â Â Â Â doc.setFont('helvetica',Â 'normal');
Â Â  
Â Â Â Â Â doc.setFontSize(8.5);
Â Â  
Â Â Â Â Â doc.setTextColor(...p.textMuted);
Â Â  
Â Â Â Â Â doc.text(
Â Â Â Â  
Â Â Â Â Â Â  'GeneratedÂ withÂ HomeÂ PokerÂ TournamentÂ Planner',
Â Â Â Â  
Â Â Â Â Â Â Â pageWidthÂ /Â 2,
Â Â Â Â  
Â Â Â Â Â Â Â pageHeightÂ -Â 6,
Â Â Â Â  
Â Â Â Â Â Â Â {Â align:Â 'center'Â }
Â Â Â Â  
Â Â Â Â Â );
Â Â  
Â Â Â Â  //Â OpenÂ exactlyÂ ONEÂ tabÂ withÂ theÂ fullÂ 2-pageÂ PDF
Â Â  
Â Â Â Â  tryÂ {
Â Â Â Â  
Â Â Â Â Â Â  constÂ blobUrlÂ =Â doc.output('bloburl');
Â Â Â Â  
Â Â Â Â Â Â  window.open(blobUrl,Â '_blank');
Â Â Â Â  
Â Â Â Â Â }Â catchÂ (e)Â {
Â Â Â Â  
Â Â Â Â Â Â  alert('ErrorÂ generatingÂ PDF:Â 'Â +Â (eÂ &&Â e.messageÂ ?Â e.messageÂ :Â e));
Â Â Â Â  
Â Â Â Â Â }
Â Â  
Â Â Â }
    </script>
</body>

</html>