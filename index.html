<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QQ737235G7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-QQ737235G7');
    </script>
    <!-- jsPDF & jsPDF-AutoTable from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js"></script>

    <meta charset="UTF-8" />
    <title>Home Poker Tournament Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />


    <style>
        :root {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #1e293b;
            background-color: #0f172a;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at top, #1e293b 0, #020617 60%);
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 24px 12px;
            box-sizing: border-box;
        }

        .app-shell {
            background: rgba(15, 23, 42, 0.96);
            border-radius: 16px;
            max-width: 960px;
            width: 100%;
            box-shadow:
                0 18px 45px rgba(0, 0, 0, 0.7),
                0 0 0 1px rgba(148, 163, 184, 0.15);
            color: #e5e7eb;
            padding: 20px 20px 24px;
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .app-shell {
                padding: 24px 28px 28px;
            }
        }

        h1 {
            margin: 0 0 4px;
            font-size: 1.6rem;
            letter-spacing: 0.03em;
        }

        .subtitle {
            margin: 0 0 16px;
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .layout {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        @media (min-width: 900px) {
            .layout {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        .card {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 14px;
            padding: 14px 14px 16px;
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.18);
            box-sizing: border-box;
        }

        .card h2 {
            margin: 0 0 10px;
            font-size: 1.05rem;
            letter-spacing: 0.02em;
            color: #e5e7eb;
        }

        .form-card {
            flex: 1.1;
            min-width: 0;
        }

        .preview-card {
            flex: 1.2;
            min-width: 0;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px 12px;
        }

        @media (min-width: 640px) {
            .form-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.85rem;
        }

        .form-row span.helper {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        label {
            font-size: 0.83rem;
            color: #e5e7eb;
        }

        input[type="number"] {
            border-radius: 9px;
            border: 1px solid #4b5563;
            background: #020617;
            padding: 7px 9px;
            color: #e5e7eb;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        input[type="number"]:focus {
            outline: 2px solid #22c55e;
            outline-offset: 1px;
            border-color: #22c55e;
        }

        .inline-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            font-size: 0.83rem;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            margin-top: 6px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #22c55e;
        }

        .breaks-config,
        .rebuys-config {
            margin-top: 4px;
            padding: 6px 8px;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px dashed rgba(148, 163, 184, 0.6);
            font-size: 0.8rem;
        }

        .btn-row {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        button {
            border-radius: 999px;
            border: none;
            padding: 9px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(to right, #22c55e, #4ade80);
            color: #022c22;
            box-shadow: 0 10px 25px rgba(34, 197, 94, 0.45);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            filter: brightness(1.03);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 6px 15px rgba(34, 197, 94, 0.4);
        }

        .small-note {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .error {
            margin-top: 6px;
            font-size: 0.8rem;
            color: #fecaca;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.78rem;
            margin-top: 8px;
        }

        th,
        td {
            padding: 4px 6px;
            border-bottom: 1px solid rgba(55, 65, 81, 0.8);
            text-align: left;
            white-space: nowrap;
        }

        th {
            font-weight: 600;
            color: #e5e7eb;
            background: rgba(15, 23, 42, 0.8);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .preview-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 4px;
            margin-bottom: 4px;
        }

        .chips-summary {
            font-size: 0.78rem;
            color: #cbd5f5;
            margin-bottom: 4px;
        }

        .tag {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 0.7rem;
            border: 1px solid rgba(148, 163, 184, 0.7);
            color: #e5e7eb;
            gap: 4px;
        }

        .tag-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #22c55e;
        }

        .muted {
            color: #9ca3af;
        }

        .scroll-box {
            max-height: 270px;
            overflow: auto;
            margin-top: 4px;
            padding-right: 2px;
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <header>
            <h1>Home Poker Tournament Planner</h1>
            <p class="subtitle">
                Input your table details and download a complete PDF guide with chip breakdown, blind schedule,
                hand-strength chart, and optional breaks/rebuys.
            </p>
        </header>

        <div class="layout">
            <!-- LEFT COLUMN: main setup -->
            <section class="card form-card">
                <h2>Setup</h2>
                <div class="form-grid">
                    <div class="form-row">
                        <label for="players">Number of players</label>
                        <input id="players" type="number" min="3" max="8" value="6" />
                        <span class="helper">Designed for 3–8 players using your chip set.</span>
                    </div>

                    <div class="form-row">
                        <label for="runtimeHours">Desired runtime (hours)</label>
                        <input id="runtimeHours" type="number" step="0.5" min="1.5" max="8" value="4" />
                        <span class="helper">Total time including breaks.</span>
                    </div>

                    <div class="form-row">
                        <div class="checkbox-row">
                            <input id="useBreaks" type="checkbox" />
                            <label for="useBreaks">Schedule breaks?</label>
                        </div>
                        <div id="breaksConfig" class="breaks-config" style="display:none;">
                            <div class="form-row" style="margin-top:2px;">
                                <label for="breakMinutes">Break length</label>
                                <div class="inline-row">
                                    <input id="breakMinutes" type="number" min="3" max="30" value="5"
                                        style="width:80px;" />
                                    <span>minutes</span>
                                </div>
                            </div>

                            <div class="form-row" style="margin-top:4px;">
                                <label for="breakFrequencyHours">Time between breaks</label>
                                <div class="inline-row">
                                    <input id="breakFrequencyHours" type="number" step="0.5" min="0.5" max="4"
                                        value="1.5" style="width:80px;" />
                                    <span>hours</span>
                                </div>
                                <span class="helper">Breaks are placed at the nearest level boundary to each
                                    interval.</span>
                            </div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="checkbox-row">
                            <input id="allowRebuys" type="checkbox" />
                            <label for="allowRebuys">Allow rebuys?</label>
                        </div>
                        <div id="rebuysConfig" class="rebuys-config" style="display:none;">
                            <div class="inline-row">
                                <span>Rebuys allowed until</span>
                                <input id="rebuyCutoffHours" type="number" step="0.5" min="0.5" max="6" value="2"
                                    style="width:70px;" />
                                <span>hours after start.</span>
                            </div>
                            <span class="helper">Rebuy stack = starting stack. Chip capacity isn’t auto-enforced
                                yet.</span>
                        </div>
                    </div>
                </div>

                <div class="btn-row">
                    <button id="generateBtn" type="button">
                        <span>Generate PDF Guide</span>
                    </button>
                    <span class="small-note">
                        PDF includes hand rankings, chip breakdown, blind schedule, breaks, and rebuy rules.
                    </span>
                </div>
                <div id="errorBox" class="error" style="display:none;"></div>
            </section>

            <!-- LEFT COLUMN: chip setup (second card) -->
            <section class="card" style="margin-top: 10px;">
                <h2>Chip Setup</h2>
                <div class="form-grid">
                    <div class="form-row">
                        <label for="chipColorsCount">Number of chip colors in use</label>
                        <input id="chipColorsCount" type="number" min="1" max="8" value="4" />
                        <span class="helper">
                            Each color usually maps to a denomination (e.g., T25, T100, T500, T1000).
                        </span>
                    </div>

                    <div class="form-row">
                        <label for="chipsInPlay">Chips to use in tournament</label>
                        <input id="chipsInPlay" type="number" min="0" value="300" />
                        <span class="helper" id="chipsInPlayHelper">
                            Will be constrained based on your chip counts and number of players.
                        </span>
                    </div>
                </div>

                <div id="chipColorsContainer" style="margin-top: 10px;">
                    <!-- Dynamic rows will be injected here by JS -->
                </div>

                <div class="small-note" id="chipSummaryNote" style="margin-top: 6px;">
                    Enter your chip counts above to see totals and recommended chips in play.
                </div>
            </section>

            <!-- RIGHT COLUMN: live preview -->
            <section class="card preview-card">
                <div class="preview-header">
                    <h2>Live Preview</h2>
                    <span class="small-note muted">
                        This is a quick reference; the full formatted version is in the PDF.
                    </span>
                </div>

                <div id="previewContent">
                    <p class="small-note muted">Adjust the settings on the left to see the preview.</p>
                </div>
            </section>
        </div>
    </div>

    <script>
        'use strict';

        // --- Core constants for chips and blinds ---

        const STARTING_STACK_VALUE = 8000;

        const CHIP_INVENTORY_PER_DENOM = {
            25: 50,
            100: 50,
            500: 50,
            1000: 50
        };

        const STARTING_STACK_BREAKDOWN = {
            25: 4,
            100: 4,
            500: 5,
            1000: 5
        };

        const BLIND_LEVELS = [
            { sb: 25, bb: 50 },
            { sb: 50, bb: 100 },
            { sb: 75, bb: 150 },
            { sb: 100, bb: 200 },
            { sb: 150, bb: 300 },
            { sb: 200, bb: 400 },
            { sb: 300, bb: 600 },
            { sb: 400, bb: 800 },
            { sb: 600, bb: 1200 },
            { sb: 800, bb: 1600 },
            { sb: 1200, bb: 2400 },
            { sb: 1500, bb: 3000 },
            { sb: 2000, bb: 4000 },
            { sb: 3000, bb: 6000 },
            { sb: 4000, bb: 8000 },
            { sb: 6000, bb: 12000 }
        ];

        // --- Utility functions ---
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }
        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function formatMinutesToClock(totalMinutes) {
            const rounded = Math.round(totalMinutes);
            const hours = Math.floor(rounded / 60);
            const minutes = rounded % 60;
            return `${hours}:${minutes.toString().padStart(2, '0')}`;
        }

        function endLevelForPlayers(players) {
            const totalChips = players * STARTING_STACK_VALUE;
            const targetBB = totalChips / 20; // rough: heads-up stacks about 10 BB each

            for (let i = 0; i < BLIND_LEVELS.length; i++) {
                if (BLIND_LEVELS[i].bb >= targetBB) {
                    return i + 1; // levels are 1-based
                }
            }
            return BLIND_LEVELS.length;
        }

        // --- Core calculation for one configuration ---

        function calculateStructure() {
            const playersInput = document.getElementById('players').value;
            const runtimeInput = document.getElementById('runtimeHours').value;
            const useBreaks = document.getElementById('useBreaks').checked;
            const allowRebuys = document.getElementById('allowRebuys').checked;

            let players = parseInt(playersInput, 10);
            let runtimeHours = parseFloat(runtimeInput);

            const errorBox = document.getElementById('errorBox');
            errorBox.style.display = 'none';
            errorBox.textContent = '';

            if (isNaN(players) || players < 3 || players > 8) {
                errorBox.textContent = 'Please enter a player count between 3 and 8.';
                errorBox.style.display = 'block';
                return null;
            }

            if (isNaN(runtimeHours) || runtimeHours < 1.5 || runtimeHours > 8) {
                errorBox.textContent = 'Please enter a runtime between 1.5 and 8 hours.';
                errorBox.style.display = 'block';
                return null;
            }

            // Break parameters
            let breakMinutes = 0;
            let breakFrequencyHours = 0;
            let totalBreaks = 0;
            let totalBreakMinutes = 0;

            if (useBreaks) {
                breakMinutes = parseFloat(document.getElementById('breakMinutes').value);
                breakFrequencyHours = parseFloat(document.getElementById('breakFrequencyHours').value);

                if (isNaN(breakMinutes) || breakMinutes <= 0) {
                    errorBox.textContent = 'Break length must be a positive number of minutes.';
                    errorBox.style.display = 'block';
                    return null;
                }
                if (isNaN(breakFrequencyHours) || breakFrequencyHours <= 0) {
                    errorBox.textContent = 'Break frequency must be a positive number of hours.';
                    errorBox.style.display = 'block';
                    return null;
                }

                totalBreaks = Math.floor(runtimeHours / breakFrequencyHours);
                totalBreakMinutes = totalBreaks * breakMinutes;
                const totalPlayMinutes = runtimeHours * 60 - totalBreakMinutes;
                if (totalPlayMinutes <= 0) {
                    errorBox.textContent = 'Break settings use up the entire runtime. Reduce break length or frequency.';
                    errorBox.style.display = 'block';
                    return null;
                }
            }

            let rebuyCutoffHours = null;
            if (allowRebuys) {
                rebuyCutoffHours = parseFloat(document.getElementById('rebuyCutoffHours').value);
                if (isNaN(rebuyCutoffHours) || rebuyCutoffHours <= 0) {
                    errorBox.textContent = 'Rebuy cutoff must be a positive number of hours.';
                    errorBox.style.display = 'block';
                    return null;
                }
                if (rebuyCutoffHours > runtimeHours) {
                    rebuyCutoffHours = runtimeHours;
                }
            }

            // Determine how many blind levels to prepare
            const levelsCount = endLevelForPlayers(players);

            const totalPlayMinutes = runtimeHours * 60 - totalBreakMinutes;
            const levelMinutes = totalPlayMinutes / levelsCount;

            // Build schedule with approximate break placements based on real-time
            const schedule = [];
            let clockMinutes = 0;
            let breaksUsed = 0;
            let nextBreakAt = useBreaks ? breakFrequencyHours * 60 : Infinity;

            for (let i = 0; i < levelsCount; i++) {
                const levelNumber = i + 1;
                const blind = BLIND_LEVELS[i];
                const levelStart = clockMinutes;
                const levelEnd = levelStart + levelMinutes;

                let breakAfter = false;
                let breakLengthForLevel = 0;

                if (useBreaks && breaksUsed < totalBreaks && levelEnd >= nextBreakAt - 0.001) {
                    // Insert a break after this level
                    breakAfter = true;
                    breakLengthForLevel = breakMinutes;
                    breaksUsed += 1;
                    nextBreakAt = (breaksUsed + 1) * breakFrequencyHours * 60;
                    clockMinutes = levelEnd + breakMinutes;
                } else {
                    clockMinutes = levelEnd;
                }

                schedule.push({
                    level: levelNumber,
                    sb: blind.sb,
                    bb: blind.bb,
                    startMinutes: levelStart,
                    endMinutes: levelEnd,
                    breakAfter,
                    breakLengthForLevel
                });
            }

            const totalStackPerPlayer = Object.entries(STARTING_STACK_BREAKDOWN)
                .reduce((sum, [denom, count]) => sum + parseInt(denom, 10) * count, 0);

            // Sanity check: just informational
            const chipUsage = {};
            Object.entries(STARTING_STACK_BREAKDOWN).forEach(([denomStr, perPlayerCount]) => {
                const denom = parseInt(denomStr, 10);
                const totalUsed = perPlayerCount * players;
                const inventory = CHIP_INVENTORY_PER_DENOM[denom];
                const remaining = inventory - totalUsed;
                chipUsage[denom] = {
                    perPlayer: perPlayerCount,
                    totalUsed,
                    remaining,
                    inventory
                };
            });

            return {
                players,
                runtimeHours,
                useBreaks,
                breakMinutes,
                breakFrequencyHours,
                totalBreaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                levelsCount,
                levelMinutes,
                schedule,
                chipUsage,
                totalStackPerPlayer
            };
        }

        // --- Preview rendering ---

        function renderPreview(structure) {
            const container = document.getElementById('previewContent');
            if (!structure) {
                container.innerHTML = '<p class="small-note muted">Adjust the settings on the left to see the preview.</p>';
                return;
            }

            const {
                players,
                runtimeHours,
                useBreaks,
                breakMinutes,
                breakFrequencyHours,
                totalBreaks,
                allowRebuys,
                rebuyCutoffHours,
                levelsCount,
                levelMinutes,
                schedule,
                chipUsage,
                totalStackPerPlayer
            } = structure;

            const chipsSummaryHtml = `
      <div class="preview-section-title">Chip Breakdown &amp; Summary</div>
      <div class="chips-summary">
        Starting stack per player: <strong>${totalStackPerPlayer.toLocaleString()}</strong> (value).
        Uses a standard 300-chip set with 4 denominations.
      </div>
      <table>
        <thead>
          <tr>
            <th>Denom</th>
            <th>Chips / Player</th>
            <th>Total Used</th>
            <th>Inventory</th>
            <th>Remaining</th>
          </tr>
        </thead>
        <tbody>
          ${Object.keys(chipUsage).sort((a, b) => parseInt(a) - parseInt(b)).map(denom => {
                const u = chipUsage[denom];
                return `
              <tr>
                <td>T${denom}</td>
                <td>${u.perPlayer}</td>
                <td>${u.totalUsed}</td>
                <td>${u.inventory}</td>
                <td>${u.remaining}</td>
              </tr>`;
            }).join('')}
        </tbody>
      </table>
    `;

            const metaHtml = `
      <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:4px;margin-bottom:6px;">
        <div class="tag">
          <span class="tag-dot"></span>
          <span>${players} player${players === 1 ? '' : 's'}</span>
        </div>
        <div class="tag">
          <span class="tag-dot" style="background:#38bdf8;"></span>
          <span>${runtimeHours} hour runtime</span>
        </div>
        <div class="tag">
          <span class="tag-dot" style="background:${useBreaks ? '#f97316' : '#6b7280'};"></span>
          <span>${useBreaks ? 'Breaks enabled' : 'No scheduled breaks'}</span>
        </div>
        <div class="tag">
          <span class="tag-dot" style="background:${allowRebuys ? '#facc15' : '#6b7280'};"></span>
          <span>${allowRebuys ? `Rebuys until ${rebuyCutoffHours}h` : 'No rebuys'}</span>
        </div>
      </div>
    `;

            const breaksLine = useBreaks
                ? `<span class="small-note">Break plan: one <strong>${breakMinutes}-minute</strong> break every <strong>${breakFrequencyHours}</strong> hours (≈ ${totalBreaks} breaks).</span>`
                : `<span class="small-note">Break plan: <strong>none</strong> (you can always call an ad hoc break at the table).</span>`;

            const rebuyLine = allowRebuys
                ? `<span class="small-note">Rebuys: allowed until <strong>${rebuyCutoffHours}</strong> hours after start (same stack as starting stack).</span>`
                : `<span class="small-note">Rebuys: <strong>not allowed</strong>.</span>`;

            const scheduleRowsHtml = schedule.map(level => {
                const start = formatMinutesToClock(level.startMinutes);
                const end = formatMinutesToClock(level.endMinutes);
                const length = `${Math.round(levelMinutes)} min`;
                const breakText = level.breakAfter ? `${level.breakLengthForLevel} min` : '';
                return `
        <tr>
          <td>${level.level}</td>
          <td>${level.sb}/${level.bb}</td>
          <td>${start}</td>
          <td>${end}</td>
          <td>${length}</td>
          <td>${breakText}</td>
        </tr>`;
            }).join('');

            const scheduleHtml = `
      <div class="preview-section-title" style="margin-top:10px;">Blind Schedule (Preview)</div>
      <span class="small-note">
        ${levelsCount} levels of approximately ${Math.round(levelMinutes)} minutes each.
      </span>
      <div class="scroll-box">
        <table>
          <thead>
            <tr>
              <th>Lvl</th>
              <th>SB/BB</th>
              <th>Starts</th>
              <th>Ends</th>
              <th>Length</th>
              <th>Break After?</th>
            </tr>
          </thead>
          <tbody>
            ${scheduleRowsHtml}
          </tbody>
        </table>
      </div>
    `;

            container.innerHTML = `
      ${metaHtml}
      ${chipsSummaryHtml}
      ${breaksLine}<br/>
      ${rebuyLine}
      ${scheduleHtml}
    `;
        }

        // --- PDF generation ---

        function generatePdf(structure) {
            if (!window.jspdf || !window.jspdf.jsPDF) {
                alert('jsPDF failed to load. Check your internet connection and reload the page.');
                return;
            }

            const {
                players,
                runtimeHours,
                useBreaks,
                breakMinutes,
                breakFrequencyHours,
                totalBreaks,
                allowRebuys,
                rebuyCutoffHours,
                levelsCount,
                levelMinutes,
                schedule,
                chipUsage,
                totalStackPerPlayer
            } = structure;

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'mm', format: 'a4' });

            let cursorY = 12;

            // Title
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.text('Home Poker Tournament Guide', 105, cursorY, { align: 'center' });
            cursorY += 8;

            doc.setFontSize(11);
            doc.setFont('helvetica', 'normal');
            doc.text(
                `Players: ${players}   •   Runtime: ${runtimeHours} hours   •   Starting stack: ${totalStackPerPlayer.toLocaleString()}`,
                105,
                cursorY,
                { align: 'center' }
            );
            cursorY += 8;

            // Section 1: Hand strength cheat sheet
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(13);
            doc.text('Quick Hand Strength Guide (Best to Worst)', 14, cursorY);
            cursorY += 4;

            const handRows = [
                ['1', 'Royal Flush', 'A-K-Q-J-10 of the same suit.'],
                ['2', 'Straight Flush', 'Five cards in sequence, same suit.'],
                ['3', 'Four of a Kind', 'Four cards of the same rank.'],
                ['4', 'Full House', 'Three of a kind + a pair.'],
                ['5', 'Flush', 'Five cards of the same suit.'],
                ['6', 'Straight', 'Five cards in sequence, mixed suits.'],
                ['7', 'Three of a Kind', 'Three cards of the same rank.'],
                ['8', 'Two Pair', 'Two different pairs.'],
                ['9', 'One Pair', 'Two cards of the same rank.'],
                ['10', 'High Card', 'No one makes a hand; highest card wins.']
            ];

            doc.autoTable({
                startY: cursorY,
                head: [['Rank', 'Hand', 'Description']],
                body: handRows,
                styles: { fontSize: 9, cellPadding: 1.5 },
                headStyles: { fillColor: [15, 23, 42], textColor: 255 }
            });

            cursorY = doc.lastAutoTable.finalY + 6;

            // Section 2: Basic table info – breaks and rebuys
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(13);
            doc.text('Table Settings & Rules', 14, cursorY);
            cursorY += 5;

            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);

            const breaksLine = useBreaks
                ? `Breaks: One ${breakMinutes}-minute break every ${breakFrequencyHours} hours (planned ≈ ${totalBreaks} breaks).`
                : 'Breaks: No scheduled breaks (host may call breaks as needed).';

            const rebuysLine = allowRebuys
                ? `Rebuys: Allowed until ${rebuyCutoffHours} hours after start. Rebuy stack = starting stack.`
                : 'Rebuys: Not allowed. Once you lose your stack you are out of the tournament.';

            doc.text(`Players: ${players}`, 14, cursorY);
            cursorY += 4;
            doc.text(`Total runtime (including breaks): ${runtimeHours} hours`, 14, cursorY);
            cursorY += 4;
            doc.text(breaksLine, 14, cursorY);
            cursorY += 4;
            doc.text(rebuysLine, 14, cursorY);
            cursorY += 6;

            // Section 3: Chip breakdown
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(13);
            doc.text('Chip Breakdown (Standard 300-Chip Set)', 14, cursorY);
            cursorY += 4;

            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.text(
                `Each player starts with ${totalStackPerPlayer.toLocaleString()} in chips using these denominations:`,
                14,
                cursorY
            );
            cursorY += 4;

            const chipBody = Object.keys(chipUsage)
                .sort((a, b) => parseInt(a) - parseInt(b))
                .map(denom => {
                    const u = chipUsage[denom];
                    return [
                        `T${denom}`,
                        String(u.perPlayer),
                        String(u.totalUsed),
                        String(u.inventory),
                        String(u.remaining)
                    ];
                });

            doc.autoTable({
                startY: cursorY,
                head: [['Denomination', 'Chips / Player', 'Total Used', 'Inventory', 'Remaining']],
                body: chipBody,
                styles: { fontSize: 9, cellPadding: 1.5 },
                headStyles: { fillColor: [15, 23, 42], textColor: 255 }
            });

            cursorY = doc.lastAutoTable.finalY + 6;

            doc.setFontSize(9);
            doc.text(
                'Note: This uses only part of a 300-chip set, leaving plenty of chips for rebuys or color-ups.',
                14,
                cursorY
            );
            cursorY += 6;

            // New page if needed
            if (cursorY > 220) {
                doc.addPage();
                cursorY = 14;
            }

            // Section 4: Blind schedule
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(13);
            doc.text('Blind Level Schedule', 14, cursorY);
            cursorY += 4;

            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.text(
                `There are ${levelsCount} levels of approximately ${Math.round(levelMinutes)} minutes of play each.`,
                14,
                cursorY
            );
            cursorY += 4;

            const scheduleBody = schedule.map(level => {
                const start = formatMinutesToClock(level.startMinutes);
                const end = formatMinutesToClock(level.endMinutes);
                const length = `${Math.round(levelMinutes)} min`;
                const breakText = level.breakAfter ? `${level.breakLengthForLevel} min break` : '';
                return [
                    String(level.level),
                    `${level.sb}/${level.bb}`,
                    start,
                    end,
                    length,
                    breakText
                ];
            });

            doc.autoTable({
                startY: cursorY,
                head: [['Lvl', 'SB/BB', 'Starts', 'Ends', 'Length', 'Break After']],
                body: scheduleBody,
                styles: { fontSize: 9, cellPadding: 1.5 },
                headStyles: { fillColor: [15, 23, 42], textColor: 255 }
            });

            // Save file
            // Save / open file
            // Open PDF in a new tab/window instead of trying to "download" it
            try {
                // This works well across desktop + iOS browsers
                doc.output('dataurlnewwindow');
            } catch (e) {
                // As a fallback, just alert the error so we know what's going on
                alert('Error generating PDF: ' + (e && e.message ? e.message : e));
            }

            // iOS browsers are bad at "downloads" triggered by JS.
            // Instead, open the PDF in a new tab so the user can share/save it.
            if (isIOS()) {
                try {
                    const blobUrl = doc.output('bloburl');
                    window.open(blobUrl, '_blank');
                } catch (e) {
                    // Fallback: data URL
                    doc.output('dataurlnewwindow');
                }
            } else {
                // Desktop and non-iOS browsers: normal download
                doc.save(filename);
            }
        }

        // --- Event wiring ---

        function recalcPreview() {
            const structure = calculateStructure();
            renderPreview(structure);
            return structure;
        }

        document.getElementById('useBreaks').addEventListener('change', (e) => {
            document.getElementById('breaksConfig').style.display = e.target.checked ? 'block' : 'none';
            recalcPreview();
        });

        document.getElementById('allowRebuys').addEventListener('change', (e) => {
            document.getElementById('rebuysConfig').style.display = e.target.checked ? 'block' : 'none';
            recalcPreview();
        });

        ['players', 'runtimeHours', 'breakMinutes', 'breakFrequencyHours', 'rebuyCutoffHours']
            .forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        recalcPreview();
                    });
                }
            });

        document.getElementById('generateBtn').addEventListener('click', () => {
            const structure = calculateStructure();
            if (!structure) return;

            // Track usage in Google Analytics if gtag is available
            if (typeof gtag === 'function') {
                gtag('event', 'generate_pdf', {
                    players: structure.players,
                    runtime_hours: structure.runtimeHours,
                    breaks_enabled: structure.useBreaks,
                    rebuys_enabled: structure.allowRebuys
                });
            }

            generatePdf(structure);
        });

        // Initial preview
        window.addEventListener('load', recalcPreview);
    </script>
</body>

</html>