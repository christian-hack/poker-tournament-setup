<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Home Poker Tournament Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QQ737235G7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QQ737235G7');
    </script>
    <!-- jsPDF & jsPDF-AutoTable from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js"></script>

    <style>
        :root {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #e5e7eb;
            background-color: #020617;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at top, #1e293b 0, #020617 60%);
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 24px 12px;
            box-sizing: border-box;
        }

        .app-shell {
            background: rgba(15, 23, 42, 0.96);
            border-radius: 16px;
            max-width: 1040px;
            width: 100%;
            box-shadow:
                0 18px 45px rgba(0, 0, 0, 0.7),
                0 0 0 1px rgba(148, 163, 184, 0.15);
            padding: 20px 20px 24px;
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .app-shell {
                padding: 24px 28px 28px;
            }
        }

        h1 {
            margin: 0 0 4px;
            font-size: 1.6rem;
            letter-spacing: 0.03em;
        }

        .subtitle {
            margin: 0 0 16px;
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .layout {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        @media (min-width: 900px) {
            .layout {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        .left-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1.1;
            min-width: 0;
        }

        .card {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 14px;
            padding: 14px 14px 16px;
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.18);
            box-sizing: border-box;
        }

        .card h2 {
            margin: 0 0 10px;
            font-size: 1.05rem;
            letter-spacing: 0.02em;
            color: #e5e7eb;
        }

        .form-card {
            min-width: 0;
        }

        .preview-card {
            flex: 1.2;
            min-width: 0;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px 12px;
        }

        @media (min-width: 640px) {
            .form-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.85rem;
        }

        .form-row span.helper {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        label {
            font-size: 0.83rem;
            color: #e5e7eb;
        }

        input[type="number"],
        input[type="text"] {
            border-radius: 9px;
            border: 1px solid #4b5563;
            background: #020617;
            padding: 7px 9px;
            color: #e5e7eb;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: 2px solid #22c55e;
            outline-offset: 1px;
            border-color: #22c55e;
        }

        .inline-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            font-size: 0.83rem;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            margin-top: 2px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #22c55e;
        }

        .breaks-config,
        .rebuys-config {
            margin-top: 4px;
            padding: 6px 8px;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px dashed rgba(148, 163, 184, 0.6);
            font-size: 0.8rem;
        }

        .btn-row {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        button {
            border-radius: 999px;
            border: none;
            padding: 9px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(to right, #22c55e, #4ade80);
            color: #022c22;
            box-shadow: 0 10px 25px rgba(34, 197, 94, 0.45);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            filter: brightness(1.03);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 6px 15px rgba(34, 197, 94, 0.4);
        }

        .small-note {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .small-note.muted {
            color: #6b7280;
        }

        .error {
            margin-top: 6px;
            font-size: 0.8rem;
            color: #fecaca;
        }

        .preview-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 6px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.78rem;
            margin-top: 4px;
        }

        th,
        td {
            padding: 4px 6px;
            border-bottom: 1px solid rgba(55, 65, 81, 0.8);
            text-align: left;
            white-space: nowrap;
        }

        th {
            font-weight: 600;
            color: #e5e7eb;
            background: rgba(15, 23, 42, 0.8);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .preview-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 6px;
            margin-bottom: 4px;
        }

        .scroll-box {
            max-height: 220px;
            overflow: auto;
            border-radius: 10px;
            border: 1px solid rgba(55, 65, 81, 0.9);
            background: rgba(15, 23, 42, 0.9);
            padding: 4px;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <header style="margin-bottom: 10px;">
            <h1>Home Poker Tournament Planner</h1>
            <p class="subtitle">
                Tune runtime, breaks, rebuys, and chip inventory. Get a suggested starting stack, blind schedule,
                and a printable PDF guide.
            </p>
        </header>

        <div class="layout">
            <!-- LEFT COLUMN: Setup + Chip Configuration -->
            <div class="left-column">
                <!-- Setup card -->
                <section class="card form-card">
                    <h2>Setup</h2>
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="players">Number of players</label>
                            <input id="players" type="number" min="3" max="10" value="6" />
                            <span class="helper">Designed for 3–10 players.</span>
                        </div>

                        <div class="form-row">
                            <label for="runtimeHours">Desired runtime (hours)</label>
                            <input id="runtimeHours" type="number" step="0.5" min="2" max="8" value="4" />
                            <span class="helper">Total duration including breaks.</span>
                        </div>

                        <div class="form-row">
                            <div class="checkbox-row">
                                <input id="useBreaks" type="checkbox" />
                                <label for="useBreaks">Schedule breaks?</label>
                            </div>
                            <div id="breaksConfig" class="breaks-config" style="display:none;">
                                <div class="form-row" style="margin-top:2px;">
                                    <label for="breakMinutes">Break length</label>
                                    <div class="inline-row">
                                        <input id="breakMinutes" type="number" min="3" max="30" value="5"
                                            style="width:80px;" />
                                        <span>minutes</span>
                                    </div>
                                </div>

                                <div class="form-row" style="margin-top:4px;">
                                    <label for="breakFrequencyHours">Time between breaks</label>
                                    <div class="inline-row">
                                        <input id="breakFrequencyHours" type="number" step="0.5" min="0.5" max="4"
                                            value="1.5" style="width:80px;" />
                                        <span>hours</span>
                                    </div>
                                    <span class="helper">Breaks are placed at levels closest to these time marks.</span>
                                </div>
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="checkbox-row">
                                <input id="allowRebuys" type="checkbox" />
                                <label for="allowRebuys">Allow rebuys?</label>
                            </div>
                            <div id="rebuysConfig" class="rebuys-config" style="display:none;">
                                <div class="inline-row">
                                    <span>Rebuys allowed until</span>
                                    <input id="rebuyCutoffHours" type="number" step="0.5" min="0.5" max="6" value="2"
                                        style="width:70px;" />
                                    <span>hours after start.</span>
                                </div>
                                <span class="helper">Each rebuy uses the same stack as the initial buy-in.</span>
                            </div>
                        </div>
                    </div>

                    <div class="btn-row">
                        <button id="generateBtn" type="button">
                            <span>Generate PDF Guide</span>
                        </button>
                        <span class="small-note">
                            The PDF opens in a new tab so you can save or share it.
                        </span>
                    </div>
                    <div id="errorBox" class="error" style="display:none;"></div>
                </section>

                <!-- Chip Setup card -->
                <section class="card">
                    <h2>Chip Setup</h2>
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="chipColorsCount">Number of chip colors in use</label>
                            <input id="chipColorsCount" type="number" min="1" max="8" value="4" />
                            <span class="helper">
                                Define each chip color’s label, value, and how many you actually have.
                            </span>
                        </div>
                    </div>

                    <div id="chipColorsContainer" style="margin-top: 8px;">
                        <!-- Rows created via JS -->
                    </div>

                    <div class="form-row" style="margin-top: 10px;">
                        <label>How many chips should starting stacks use?</label>
                        <div class="inline-row" style="flex-wrap: wrap; gap: 8px;">
                            <label><input type="radio" name="stackUsageMode" value="some" checked /> Some</label>
                            <label><input type="radio" name="stackUsageMode" value="half" /> About half</label>
                            <label><input type="radio" name="stackUsageMode" value="most" /> Most</label>
                            <label><input type="radio" name="stackUsageMode" value="max" /> As many as possible</label>
                        </div>
                        <span class="helper" id="stackUsageHelper">
                            We'll choose a stack size based on total chips and player count.
                        </span>
                    </div>

                    <div class="small-note" id="chipSummaryNote" style="margin-top: 6px;">
                        Enter chip counts and values above to see a suggested starting stack per player.
                    </div>
                </section>
            </div>

            <!-- RIGHT COLUMN: preview -->
            <section class="card preview-card">
                <div class="preview-header">
                    <h2>Live Preview</h2>
                    <span class="small-note muted">
                        Adjust settings on the left to see stack suggestions and blind levels.
                    </span>
                </div>

                <div id="previewContent">
                    <p class="small-note muted">
                        Enter players, runtime, and chip info to see the suggested structure.
                    </p>
                </div>
            </section>
        </div>
    </div>

    <script>
        'use strict';

        // --- Helpers & globals ---
        function clamp(v, min, max) {
            if (isNaN(v)) return min;
            return Math.max(min, Math.min(max, v));
        }

        let chipColorRows = [];            // { nameInput, valueInput, countInput }
        let currentStackSuggestion = null; // { chipsPerPlayer, totalValuePerPlayer, colors[] }
        const MIN_CHIPS_PER_PLAYER = 12;

        // --- Initialization ---
        window.addEventListener('load', () => {
            setupFormInteractions();
            initChipColorsUI();
            recalcAll();
        });

        function setupFormInteractions() {
            const useBreaks = document.getElementById('useBreaks');
            const breaksConfig = document.getElementById('breaksConfig');
            const allowRebuys = document.getElementById('allowRebuys');
            const rebuysConfig = document.getElementById('rebuysConfig');

            useBreaks.addEventListener('change', () => {
                breaksConfig.style.display = useBreaks.checked ? 'block' : 'none';
                recalcAll();
            });

            allowRebuys.addEventListener('change', () => {
                rebuysConfig.style.display = allowRebuys.checked ? 'block' : 'none';
                recalcAll();
            });

            ['players', 'runtimeHours', 'breakMinutes', 'breakFrequencyHours', 'rebuyCutoffHours'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', recalcAll);
                }
            });

            document.getElementById('generateBtn').addEventListener('click', () => {
                const structure = calculateStructure();
                if (!structure) return;

                // Track usage in Google Analytics if gtag is available
                if (typeof gtag === 'function') {
                    gtag('event', 'generate_pdf', {
                        players: structure.players,
                        runtime_hours: structure.runtimeHours,
                        breaks_enabled: structure.useBreaks,
                        rebuys_enabled: structure.allowRebuys
                    });
                }
                generatePdf(structure);
            });
        }

        function recalcAll() {
            recalcChipUsageAndStacks();
            const structure = calculateStructure();
            renderPreview(structure);
        }

        // --- Chip Setup UI & suggestion logic ---
        function initChipColorsUI() {
            const chipColorsCountInput = document.getElementById('chipColorsCount');
            const container = document.getElementById('chipColorsContainer');

            function rebuildRows() {
                const count = clamp(parseInt(chipColorsCountInput.value || '0', 10), 1, 8);
                chipColorsCountInput.value = count;

                container.innerHTML = '';
                chipColorRows = [];

                for (let i = 0; i < count; i++) {
                    const row = document.createElement('div');
                    row.className = 'inline-row';
                    row.style.marginTop = '4px';
                    row.style.flexWrap = 'wrap';
                    row.style.gap = '6px';

                    const labelSpan = document.createElement('span');
                    labelSpan.textContent = `Color ${i + 1}:`;

                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.placeholder = `Label (e.g. T${i === 0 ? 25 : i === 1 ? 100 : i === 2 ? 500 : 1000})`;
                    nameInput.style.width = '140px';
                    nameInput.style.borderRadius = '9px';
                    nameInput.style.border = '1px solid #4b5563';
                    nameInput.style.background = '#020617';
                    nameInput.style.color = '#e5e7eb';
                    nameInput.style.padding = '6px 8px';
                    nameInput.style.fontSize = '0.85rem';

                    const valueLabel = document.createElement('span');
                    valueLabel.textContent = 'Value:';

                    const valueInput = document.createElement('input');
                    valueInput.type = 'number';
                    valueInput.min = '1';
                    valueInput.placeholder = i === 0 ? '25' : i === 1 ? '100' : i === 2 ? '500' : '1000';
                    valueInput.style.width = '80px';

                    const countLabel = document.createElement('span');
                    countLabel.textContent = 'Available:';

                    const countInput = document.createElement('input');
                    countInput.type = 'number';
                    countInput.min = '0';
                    countInput.value = '50';
                    countInput.style.width = '80px';

                    row.appendChild(labelSpan);
                    row.appendChild(nameInput);
                    row.appendChild(valueLabel);
                    row.appendChild(valueInput);
                    row.appendChild(countLabel);
                    row.appendChild(countInput);
                    container.appendChild(row);

                    chipColorRows.push({ nameInput, valueInput, countInput });

                    nameInput.addEventListener('input', () => {
                        recalcChipUsageAndStacks();
                        recalcAll();
                    });
                    valueInput.addEventListener('input', () => {
                        recalcChipUsageAndStacks();
                        recalcAll();
                    });
                    countInput.addEventListener('input', () => {
                        recalcChipUsageAndStacks();
                        recalcAll();
                    });
                }

                recalcChipUsageAndStacks();
            }

            chipColorsCountInput.addEventListener('input', () => {
                rebuildRows();
                recalcAll();
            });

            document.querySelectorAll('input[name="stackUsageMode"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    recalcChipUsageAndStacks();
                    recalcAll();
                });
            });

            rebuildRows();
        }

        function recalcChipUsageAndStacks() {
            const playersInput = document.getElementById('players');
            const helper = document.getElementById('stackUsageHelper');
            const summaryNote = document.getElementById('chipSummaryNote');

            const players = clamp(parseInt(playersInput.value || '0', 10), 1, 50);

            const colors = [];
            chipColorRows.forEach((row, idx) => {
                const rawName = row.nameInput.value.trim();
                const name = rawName || `Color ${idx + 1}`;
                const count = parseInt(row.countInput.value || '0', 10);
                const rawVal = row.valueInput.value.trim();
                const value = rawVal ? parseFloat(rawVal) : (idx === 0 ? 25 : idx === 1 ? 100 : idx === 2 ? 500 : 1000);

                if (!isNaN(count) && count > 0) {
                    colors.push({ name, count, value, index: idx });
                }
            });

            const totalChips = colors.reduce((sum, c) => sum + c.count, 0);

            if (totalChips === 0 || !players) {
                helper.textContent = 'Enter chip counts, values, and number of players to see a suggested stack.';
                summaryNote.textContent = 'No chip counts or players yet.';
                currentStackSuggestion = null;
                return;
            }

            const modeRadio = document.querySelector('input[name="stackUsageMode"]:checked');
            const mode = modeRadio ? modeRadio.value : 'half';
            const usageFractions = { some: 0.25, half: 0.5, most: 0.75, max: 0.9 };
            let fraction = usageFractions[mode] || 0.5;

            let chipsForStacks = Math.floor(totalChips * fraction);
            const minNeeded = players * MIN_CHIPS_PER_PLAYER;

            if (chipsForStacks < minNeeded) {
                chipsForStacks = Math.min(minNeeded, totalChips);
            }
            if (chipsForStacks <= 0) {
                helper.textContent = 'Not enough chips to build a starting stack.';
                summaryNote.textContent = `Total available chips: ${totalChips}.`;
                currentStackSuggestion = null;
                return;
            }

            const chipsPerPlayer = Math.floor(chipsForStacks / players);
            if (chipsPerPlayer < MIN_CHIPS_PER_PLAYER) {
                helper.textContent =
                    `Not enough chips for ${players} players. ` +
                    `Try reducing players or increasing chip counts.`;
                summaryNote.textContent =
                    `Total available chips: ${totalChips}. ` +
                    `Even distribution would give only ${chipsPerPlayer} chips per player.`;
                currentStackSuggestion = null;
                return;
            }

            colors.sort((a, b) => a.value - b.value);

            const perPlayer = colors.map(c => ({
                name: c.name,
                value: c.value,
                available: c.count,
                perPlayerCount: 0,
                maxPerPlayer: Math.floor(c.count / players)
            }));

            const N = perPlayer.length;
            const baseTarget = Math.floor(chipsPerPlayer / N);
            let assignedTotal = 0;

            for (let i = 0; i < N; i++) {
                const cap = perPlayer[i].maxPerPlayer;
                const given = Math.min(baseTarget, cap);
                perPlayer[i].perPlayerCount = given;
                assignedTotal += given;
            }

            let leftover = chipsPerPlayer - assignedTotal;
            while (leftover > 0) {
                let addedThisLoop = 0;
                for (let i = 0; i < N && leftover > 0; i++) {
                    if (perPlayer[i].perPlayerCount < perPlayer[i].maxPerPlayer) {
                        perPlayer[i].perPlayerCount += 1;
                        leftover -= 1;
                        addedThisLoop += 1;
                    }
                }
                if (addedThisLoop === 0) break;
            }

            const totalValuePerPlayer = perPlayer.reduce(
                (sum, c) => sum + c.perPlayerCount * c.value,
                0
            );

            helper.textContent =
                `You have ${totalChips} chips across ${N} colors. Mode “${mode}” uses about ` +
                `${chipsPerPlayer * players} chips total (~${chipsPerPlayer} per player).`;

            summaryNote.textContent =
                `Suggested starting stack: ~${chipsPerPlayer} chips per player, ` +
                `worth about ${totalValuePerPlayer.toLocaleString()} in chip value.`;

            currentStackSuggestion = {
                chipsPerPlayer,
                totalValuePerPlayer,
                colors: perPlayer
            };
        }

        // --- Tournament structure calculation ---
        function calculateStructure() {
            const errorBox = document.getElementById('errorBox');
            errorBox.style.display = 'none';
            errorBox.textContent = '';

            const players = clamp(parseInt(document.getElementById('players').value || '0', 10), 1, 50);
            const runtimeHours = Math.max(0, parseFloat(document.getElementById('runtimeHours').value || '0'));

            if (!players || runtimeHours <= 0) {
                errorBox.style.display = 'block';
                errorBox.textContent = 'Please enter a valid number of players and runtime.';
                return null;
            }

            const useBreaks = document.getElementById('useBreaks').checked;
            const allowRebuys = document.getElementById('allowRebuys').checked;

            let breakMinutes = 0;
            let breakFrequencyHours = 0;
            let breaks = [];

            if (useBreaks) {
                breakMinutes = Math.max(0, parseInt(document.getElementById('breakMinutes').value || '0', 10));
                breakFrequencyHours = Math.max(0.25, parseFloat(document.getElementById('breakFrequencyHours').value || '0'));
                if (breakMinutes > 0) {
                    let t = breakFrequencyHours;
                    while (t < runtimeHours) {
                        breaks.push({ atHour: t, minutes: breakMinutes });
                        t += breakFrequencyHours;
                    }
                }
            }

            const totalBreakMinutes = breaks.reduce((sum, b) => sum + b.minutes, 0);
            let effectiveMinutes = runtimeHours * 60 - totalBreakMinutes;
            if (effectiveMinutes < 60) effectiveMinutes = 60;

            const levelMinutes = 12;
            let levelsCount = Math.floor(effectiveMinutes / levelMinutes);
            if (levelsCount < 6) levelsCount = 6;

            let startingStackValue = 8000;
            if (currentStackSuggestion && currentStackSuggestion.totalValuePerPlayer > 0) {
                startingStackValue = currentStackSuggestion.totalValuePerPlayer;
            }

            const chipValues = [];
            chipColorRows.forEach((row, idx) => {
                const rawVal = row.valueInput.value.trim();
                const value = rawVal ? parseFloat(rawVal) : (idx === 0 ? 25 : idx === 1 ? 100 : idx === 2 ? 500 : 1000);
                if (!isNaN(value) && value > 0) chipValues.push(value);
            });
            const minChip = chipValues.length ? Math.min(...chipValues) : 25;

            const baseSB = minChip;
            const schedule = [];
            const totalMinutesNoBreaks = runtimeHours * 60;
            let elapsed = 0;
            let blindSB = baseSB;
            let blindBB = blindSB * 2;

            for (let level = 1; level <= levelsCount; level++) {
                const levelStartMin = elapsed;
                const levelEndMin = elapsed + levelMinutes;

                schedule.push({
                    level,
                    startMin: levelStartMin,
                    endMin: levelEndMin,
                    sb: Math.round(blindSB),
                    bb: Math.round(blindBB)
                });

                elapsed += levelMinutes;
                blindSB *= 1.5;
                blindBB = blindSB * 2;
            }

            let rebuyCutoffHours = null;
            if (allowRebuys) {
                rebuyCutoffHours = Math.min(
                    runtimeHours,
                    Math.max(0.5, parseFloat(document.getElementById('rebuyCutoffHours').value || '0'))
                );
            }

            return {
                players,
                runtimeHours,
                useBreaks,
                breakMinutes,
                breakFrequencyHours,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                levelsCount,
                levelMinutes,
                schedule,
                startingStackValue
            };
        }

        // --- Preview rendering ---
        function renderPreview(structure) {
            const container = document.getElementById('previewContent');

            if (!structure) {
                container.innerHTML = '<p class="small-note muted">Fix errors on the left to see the preview.</p>';
                return;
            }

            const {
                players,
                runtimeHours,
                useBreaks,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                schedule,
                levelMinutes,
                startingStackValue
            } = structure;

            const runtimeStr = runtimeHours.toFixed(1).replace(/\.0$/, '');
            const metaHtml = `
        <div class="preview-section-title">Tournament Summary</div>
        <table>
          <tbody>
            <tr><td>Players</td><td>${players}</td></tr>
            <tr><td>Runtime</td><td>${runtimeStr} hours</td></tr>
            <tr><td>Level length</td><td>${levelMinutes} minutes</td></tr>
            <tr><td>Starting stack value</td><td>${startingStackValue.toLocaleString()}</td></tr>
          </tbody>
        </table>
      `;

            let breaksHtml = '';
            if (useBreaks && breaks.length) {
                const rows = breaks.map((b, idx) => {
                    const atMin = Math.round(b.atHour * 60);
                    return `<tr><td>Break ${idx + 1}</td><td>${b.minutes} min</td><td>${formatMinutes(atMin)}</td></tr>`;
                }).join('');
                breaksHtml = `
          <div class="preview-section-title">Breaks</div>
          <div class="scroll-box">
            <table>
              <thead>
                <tr><th>#</th><th>Length</th><th>Approx. Time</th></tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
          <span class="small-note">
            Total break time: ${totalBreakMinutes} minutes.
          </span>
        `;
            } else {
                breaksHtml = `
          <div class="preview-section-title">Breaks</div>
          <span class="small-note muted">
            No scheduled breaks, or break config not enabled.
          </span>
        `;
            }

            let rebuysHtml = '';
            if (allowRebuys && rebuyCutoffHours) {
                rebuysHtml = `
          <div class="preview-section-title">Rebuys</div>
          <span class="small-note">
            Rebuys allowed until ${rebuyCutoffHours.toFixed(1).replace(/\.0$/, '')} hours after start.
            Each rebuy uses the same stack as the initial buy-in.
          </span>
        `;
            } else {
                rebuysHtml = `
          <div class="preview-section-title">Rebuys</div>
          <span class="small-note muted">
            Rebuys disabled.
          </span>
        `;
            }

            let startingStackHtml = '';
            if (currentStackSuggestion) {
                const stack = currentStackSuggestion;
                const rowsHtml = stack.colors
                    .filter(c => c.perPlayerCount > 0)
                    .map(c => {
                        const totalUsed = c.perPlayerCount * structure.players;
                        return `
              <tr>
                <td>${c.name}</td>
                <td>${c.value}</td>
                <td>${c.perPlayerCount}</td>
                <td>${totalUsed}</td>
              </tr>`;
                    })
                    .join('');

                startingStackHtml = `
          <div class="preview-section-title">Suggested Starting Stack (per player)</div>
          <span class="small-note">
            Approx. ${stack.chipsPerPlayer} chips per player, total value ~${stack.totalValuePerPlayer.toLocaleString()}.
          </span>
          <div class="scroll-box">
            <table>
              <thead>
                <tr>
                  <th>Color</th>
                  <th>Value</th>
                  <th>Chips / Player</th>
                  <th>Total Used</th>
                </tr>
              </thead>
              <tbody>${rowsHtml}</tbody>
            </table>
          </div>
        `;
            } else {
                startingStackHtml = `
          <div class="preview-section-title">Suggested Starting Stack (per player)</div>
          <span class="small-note muted">
            Define chip colors, values, and counts to see a suggested stack.
          </span>
        `;
            }

            const scheduleRows = schedule.map(l => `
        <tr>
          <td>${l.level}</td>
          <td>${formatMinutes(l.startMin)}</td>
          <td>${formatMinutes(l.endMin)}</td>
          <td>${l.sb}</td>
          <td>${l.bb}</td>
        </tr>
      `).join('');

            const scheduleHtml = `
        <div class="preview-section-title">Blind Schedule</div>
        <div class="scroll-box">
          <table>
            <thead>
              <tr>
                <th>Lvl</th>
                <th>Start</th>
                <th>End</th>
                <th>SB</th>
                <th>BB</th>
              </tr>
            </thead>
            <tbody>${scheduleRows}</tbody>
          </table>
        </div>
      `;

            container.innerHTML = `
        ${metaHtml}
        ${startingStackHtml}
        ${breaksHtml}
        ${rebuysHtml}
        ${scheduleHtml}
      `;
        }

        function formatMinutes(min) {
            const h = Math.floor(min / 60);
            const m = min % 60;
            const hStr = h === 0 ? '0' : h.toString();
            const mStr = m.toString().padStart(2, '0');
            return `${hStr}:${mStr}`;
        }

        // --- PDF generation ---
        function generatePdf(structure) {
            if (!window.jspdf || !window.jspdf.jsPDF) {
                alert('PDF engine (jsPDF) did not load. Check your connection and try again.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'mm', format: 'a4' });

            const {
                players,
                runtimeHours,
                useBreaks,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                schedule,
                levelMinutes,
                startingStackValue
            } = structure;

            let y = 10;

            doc.setFontSize(18);
            doc.text('Home Poker Tournament Guide', 105, y, { align: 'center' });
            y += 8;
            doc.setFontSize(11);
            doc.text(`Players: ${players}   Runtime: ${runtimeHours.toFixed(1).replace(/\.0$/, '')} hours`, 105, y, { align: 'center' });
            y += 6;

            // Hand ranking quick guide
            doc.setFontSize(13);
            doc.text('Hand Rankings (Strongest to Weakest)', 10, y);
            y += 5;
            doc.setFontSize(9);
            const hands = [
                'Royal Flush',
                'Straight Flush',
                'Four of a Kind',
                'Full House',
                'Flush',
                'Straight',
                'Three of a Kind',
                'Two Pair',
                'One Pair',
                'High Card'
            ];
            hands.forEach(h => {
                doc.text('- ' + h, 12, y);
                y += 4;
            });

            y += 3;
            doc.setFontSize(12);
            doc.text('Tournament Summary', 10, y);
            y += 4;
            doc.setFontSize(10);
            doc.text(`Players: ${players}`, 12, y); y += 4;
            doc.text(`Runtime: ${runtimeHours.toFixed(1).replace(/\.0$/, '')} hours`, 12, y); y += 4;
            doc.text(`Level length: ${levelMinutes} minutes`, 12, y); y += 4;
            doc.text(`Starting stack value (approx.): ${startingStackValue.toLocaleString()}`, 12, y); y += 4;

            if (useBreaks && breaks.length) {
                doc.text(`Total break time: ${totalBreakMinutes} minutes`, 12, y); y += 4;
            } else {
                doc.text('Breaks: none scheduled', 12, y); y += 4;
            }

            if (allowRebuys && rebuyCutoffHours) {
                doc.text(
                    `Rebuys: allowed until ${rebuyCutoffHours.toFixed(1).replace(/\.0$/, '')} hours from start`,
                    12,
                    y
                );
                y += 4;
            } else {
                doc.text('Rebuys: not allowed', 12, y); y += 4;
            }

            // Suggested starting stack table
            if (currentStackSuggestion && currentStackSuggestion.colors.some(c => c.perPlayerCount > 0)) {
                y += 2;
                doc.setFontSize(12);
                doc.text('Suggested Starting Stack (per player)', 10, y);
                y += 2;

                const autoTable = doc.autoTable;
                if (autoTable) {
                    doc.autoTable({
                        startY: y,
                        head: [['Color', 'Value', 'Chips / Player', 'Total Used']],
                        body: currentStackSuggestion.colors
                            .filter(c => c.perPlayerCount > 0)
                            .map(c => [
                                c.name,
                                String(c.value),
                                String(c.perPlayerCount),
                                String(c.perPlayerCount * players)
                            ]),
                        styles: { fontSize: 9 },
                        headStyles: { fillColor: [15, 23, 42] }
                    });
                    y = doc.lastAutoTable.finalY + 4;
                }
            }

            // Blind schedule table
            doc.setFontSize(12);
            doc.text('Blind Schedule', 10, y);
            y += 2;

            if (doc.autoTable) {
                doc.autoTable({
                    startY: y,
                    head: [['Lvl', 'Start', 'End', 'SB', 'BB']],
                    body: schedule.map(l => [
                        String(l.level),
                        formatMinutes(l.startMin),
                        formatMinutes(l.endMin),
                        String(l.sb),
                        String(l.bb)
                    ]),
                    styles: { fontSize: 9 },
                    headStyles: { fillColor: [15, 23, 42] }
                });
            }

            // For mobile (iOS etc.): open PDF in new tab/window instead of trying file download
            try {
                doc.output('dataurlnewwindow');
            } catch (e) {
                alert('Error generating PDF: ' + (e && e.message ? e.message : e));
            }
        }
    </script>
</body>

</html>