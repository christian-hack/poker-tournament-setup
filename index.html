<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Home Poker Tournament Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QQ737235G7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QQ737235G7');
    </script>
    <!-- jsPDF & jsPDF-AutoTable from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js"></script>

    <style>
        :root {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #e5e7eb;
            background-color: #020617;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at top, #1e293b 0, #020617 60%);
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 24px 12px;
            box-sizing: border-box;
        }

        .app-shell {
            background: rgba(15, 23, 42, 0.96);
            border-radius: 16px;
            max-width: 1040px;
            width: 100%;
            box-shadow:
                0 18px 45px rgba(0, 0, 0, 0.7),
                0 0 0 1px rgba(148, 163, 184, 0.15);
            padding: 20px 20px 24px;
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .app-shell {
                padding: 24px 28px 28px;
            }
        }

        h1 {
            margin: 0 0 4px;
            font-size: 1.6rem;
            letter-spacing: 0.03em;
        }

        .subtitle {
            margin: 0 0 16px;
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .layout {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        @media (min-width: 900px) {
            .layout {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        .left-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1.1;
            min-width: 0;
        }

        .card {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 14px;
            padding: 14px 14px 16px;
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.18);
            box-sizing: border-box;
        }

        .card h2 {
            margin: 0 0 10px;
            font-size: 1.05rem;
            letter-spacing: 0.02em;
            color: #e5e7eb;
        }

        .form-card {
            min-width: 0;
        }

        .preview-card {
            flex: 1.2;
            min-width: 0;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px 12px;
        }

        @media (min-width: 640px) {
            .form-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.85rem;
        }

        .form-row span.helper {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        label {
            font-size: 0.83rem;
            color: #e5e7eb;
        }

        input[type="number"],
        select {
            border-radius: 9px;
            border: 1px solid #4b5563;
            background: #020617;
            padding: 7px 9px;
            color: #e5e7eb;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        input[type="number"]:focus,
        select:focus {
            outline: 2px solid #22c55e;
            outline-offset: 1px;
            border-color: #22c55e;
        }

        .inline-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            font-size: 0.83rem;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            margin-top: 2px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #22c55e;
        }

        .breaks-config,
        .rebuys-config {
            margin-top: 4px;
            padding: 6px 8px;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px dashed rgba(148, 163, 184, 0.6);
            font-size: 0.8rem;
        }

        .btn-row {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        button {
            border-radius: 999px;
            border: none;
            padding: 9px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(to right, #22c55e, #4ade80);
            color: #022c22;
            box-shadow: 0 10px 25px rgba(34, 197, 94, 0.45);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            filter: brightness(1.03);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 6px 15px rgba(34, 197, 94, 0.4);
        }

        .small-note {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .small-note.muted {
            color: #6b7280;
        }

        .error {
            margin-top: 6px;
            font-size: 0.8rem;
            color: #fecaca;
        }

        .preview-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 6px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.78rem;
            margin-top: 4px;
        }

        th,
        td {
            padding: 4px 6px;
            border-bottom: 1px solid rgba(55, 65, 81, 0.8);
            text-align: left;
            white-space: nowrap;
        }

        th {
            font-weight: 600;
            color: #e5e7eb;
            background: rgba(15, 23, 42, 0.8);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .preview-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 6px;
            margin-bottom: 4px;
        }

        .scroll-box {
            max-height: 220px;
            overflow: auto;
            border-radius: 10px;
            border: 1px solid rgba(55, 65, 81, 0.9);
            background: rgba(15, 23, 42, 0.9);
            padding: 4px;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div class="app-shell">
        <header style="margin-bottom: 10px;">
            <h1>Home Poker Tournament Planner</h1>
            <p class="subtitle">
                Tune runtime, breaks, rebuys, and chip inventory. Get a suggested starting stack, blind schedule,
                and a printable PDF guide.
            </p>
        </header>

        <div class="layout">
            <!-- LEFT COLUMN: Setup + Chip Configuration -->
            <div class="left-column">
                <!-- Setup card -->
                <section class="card form-card">
                    <h2>Setup</h2>
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="players">Number of players</label>
                            <input id="players" type="number" min="3" max="10" value="6" />
                            <span class="helper">Designed for 3â€“10 players.</span>
                        </div>

                        <div class="form-row">
                            <label for="runtimeHours">Desired runtime (hours)</label>
                            <input id="runtimeHours" type="number" step="0.5" min="2" max="8" value="4" />
                            <span class="helper">Total duration including breaks.</span>
                        </div>

                        <div class="form-row">
                            <label for="structureSpeed">Structure speed</label>
                            <select id="structureSpeed">
                                <option value="slow">Slow (deeper, longer)</option>
                                <option value="normal" selected>Normal</option>
                                <option value="turbo">Turbo (faster)</option>
                            </select>
                            <span class="helper">
                                Controls how quickly blinds grow for the same runtime.
                            </span>
                        </div>

                        <div class="form-row">
                            <div class="checkbox-row">
                                <input id="useBreaks" type="checkbox" />
                                <label for="useBreaks">Schedule breaks?</label>
                            </div>
                            <div id="breaksConfig" class="breaks-config" style="display:none;">
                                <div class="form-row" style="margin-top:2px;">
                                    <label for="breakMinutes">Break length</label>
                                    <div class="inline-row">
                                        <input id="breakMinutes" type="number" min="3" max="30" value="5"
                                            style="width:80px;" />
                                        <span>minutes</span>
                                    </div>
                                </div>

                                <div class="form-row" style="margin-top:4px;">
                                    <label for="breakFrequencyHours">Time between breaks</label>
                                    <div class="inline-row">
                                        <input id="breakFrequencyHours" type="number" step="0.5" min="0.5" max="4"
                                            value="1.5" style="width:80px;" />
                                        <span>hours</span>
                                    </div>
                                    <span class="helper">Breaks are placed at levels closest to these time marks.</span>
                                </div>
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="checkbox-row">
                                <input id="allowRebuys" type="checkbox" />
                                <label for="allowRebuys">Allow rebuys?</label>
                            </div>
                            <div id="rebuysConfig" class="rebuys-config" style="display:none;">
                                <div class="inline-row">
                                    <span>Rebuys allowed until</span>
                                    <input id="rebuyCutoffHours" type="number" step="0.5" min="0.5" max="6" value="2"
                                        style="width:70px;" />
                                    <span>hours after start.</span>
                                </div>
                                <span class="helper">Each rebuy uses the same stack as the initial buy-in.</span>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Chip Setup card -->
                <section class="card">
                    <h2>Chip Setup</h2>
                    <div class="form-grid">
                        <div class="form-row">
                            <label for="chipColorsCount">Number of chip colors:</label>
                            <input id="chipColorsCount" type="number" min="1" max="5" value="4" />
                            <span class="helper">
                                Choose from White, Red, Green, Blue, Black. The app assumes the usual value order.
                            </span>
                        </div>
                    </div>

                    <div id="chipColorsContainer" style="margin-top: 8px;">
                        <!-- Rows created via JS -->
                    </div>

                    <div class="form-row" style="margin-top: 10px;">
                        <label>How many chips should starting stacks use?</label>
                        <div class="inline-row" style="flex-wrap: wrap; gap: 8px;">
                            <label><input type="radio" name="stackUsageMode" value="some" checked /> Some</label>
                            <label><input type="radio" name="stackUsageMode" value="half" /> About half</label>
                            <label><input type="radio" name="stackUsageMode" value="most" /> Most</label>
                            <label><input type="radio" name="stackUsageMode" value="max" /> As many as possible</label>
                        </div>
                        <span class="helper" id="stackUsageHelper">
                            We'll choose a stack size based on total chips and player count.
                        </span>
                    </div>

                    <div class="form-row" style="margin-top: 8px;">
                        <label>Chip value scale</label>
                        <div class="inline-row">
                            <button type="button" id="decreaseValuesBtn">Decrease values</button>
                            <button type="button" id="increaseValuesBtn">Increase values</button>
                        </div>
                        <span class="helper" id="valueScaleLabel">
                            Current values will be shown here after you enter chip colors.
                        </span>
                    </div>

                    <div class="small-note" id="chipSummaryNote" style="margin-top: 6px;">
                        Enter chip counts above to see a suggested starting stack per player.
                    </div>
                    <div class="btn-row">
                        <button id="generateBtn" type="button">
                            <span>Generate PDF Guide</span>
                        </button>
                        <span class="small-note">
                            The PDF opens in a new tab so you can save or share it.
                        </span>
                    </div>
                    <div id="errorBox" class="error" style="display:none;"></div>
                </section>
            </div>

            <!-- RIGHT COLUMN: preview -->
            <section class="card preview-card">
                <div class="preview-header">
                    <h2>Live Preview</h2>
                    <span class="small-note muted">
                        Adjust settings on the left to see stack suggestions and blind levels.
                    </span>
                </div>

                <div id="previewContent">
                    <p class="small-note muted">
                        Enter players, runtime, and chip info to see the suggested structure.
                    </p>
                </div>
            </section>
        </div>
    </div>

    <script>
        'use strict';

        // --- Helpers & globals ---
        function clamp(v, min, max) {
            if (isNaN(v)) return min;
            return Math.max(min, Math.min(max, v));
        }
        function roundToUnit(value, unit) {
            if (!unit || unit <= 0) return Math.round(value);
            return Math.max(unit, Math.round(value / unit) * unit);
        }

        const COLOR_OPTIONS = ['White', 'Red', 'Green', 'Blue', 'Black'];
        let chipColorRows = [];            // { colorSelect, countInput }
        let currentStackSuggestion = null; // { chipsPerPlayer, totalValuePerPlayer, colors[] }
        let valueScaleStep = 0;            // 0 = base, +1 = x2, -1 = x0.5, etc.
        const MIN_CHIPS_PER_PLAYER = 12;

        window.addEventListener('load', () => {
            setupFormInteractions();
            initChipColorsUI();

            // Force default states (iOS browsers like to restore old states)
            document.getElementById('useBreaks').checked = false;
            document.getElementById('allowRebuys').checked = false;

            document.getElementById('breaksConfig').style.display = 'none';
            document.getElementById('rebuysConfig').style.display = 'none';

            recalcAll();
        });


        function setupFormInteractions() {
            const useBreaks = document.getElementById('useBreaks');
            const breaksConfig = document.getElementById('breaksConfig');
            const allowRebuys = document.getElementById('allowRebuys');
            const rebuysConfig = document.getElementById('rebuysConfig');
            const speedSelect = document.getElementById('structureSpeed');
            if (speedSelect) {
              speedSelect.addEventListener('change', recalcAll);
            }

            useBreaks.addEventListener('change', () => {
                breaksConfig.style.display = useBreaks.checked ? 'block' : 'none';
                recalcAll();
            });

            allowRebuys.addEventListener('change', () => {
                rebuysConfig.style.display = allowRebuys.checked ? 'block' : 'none';
                recalcAll();
            });

            ['players', 'runtimeHours', 'breakMinutes', 'breakFrequencyHours', 'rebuyCutoffHours'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', recalcAll);
                }
            });

            document.querySelectorAll('input[name="stackUsageMode"]').forEach(radio => {
                radio.addEventListener('change', recalcAll);
            });

            document.getElementById('decreaseValuesBtn').addEventListener('click', () => {
                valueScaleStep = Math.max(valueScaleStep - 1, -2); // limit how tiny it gets
                recalcAll();
            });

            document.getElementById('increaseValuesBtn').addEventListener('click', () => {
                valueScaleStep = Math.min(valueScaleStep + 1, 3); // limit how huge it gets
                recalcAll();
            });

            document.getElementById('generateBtn').addEventListener('click', () => {
                const structure = calculateStructure();
                if (!structure) return;

                // Track usage in Google Analytics if gtag is available
                if (typeof gtag === 'function') {
                    gtag('event', 'generate_pdf', {
                        players: structure.players,
                        runtime_hours: structure.runtimeHours,
                        breaks_enabled: structure.useBreaks,
                        rebuys_enabled: structure.allowRebuys
                    });
                }
                generatePdf(structure);
            });
        }

        function recalcAll() {
            recalcChipUsageAndStacks();
            const structure = calculateStructure();
            renderPreview(structure);
        }

        // --- Chip Setup UI ---
        function initChipColorsUI() {
            const chipColorsCountInput = document.getElementById('chipColorsCount');
            const container = document.getElementById('chipColorsContainer');

            function rebuildRows() {
                const count = clamp(parseInt(chipColorsCountInput.value || '0', 10), 1, 5);
                chipColorsCountInput.value = count;

                container.innerHTML = '';
                chipColorRows = [];

                for (let i = 0; i < count; i++) {
                    const row = document.createElement('div');
                    row.className = 'inline-row';
                    row.style.marginTop = '4px';
                    row.style.flexWrap = 'wrap';
                    row.style.gap = '6px';

                    const labelSpan = document.createElement('span');
                    labelSpan.textContent = `Color ${i + 1}:`;

                    const colorSelect = document.createElement('select');
                    COLOR_OPTIONS.forEach((color, idx) => {
                        const opt = document.createElement('option');
                        opt.value = color;
                        opt.textContent = color;
                        colorSelect.appendChild(opt);
                    });
                    colorSelect.selectedIndex = i < COLOR_OPTIONS.length ? i : 0;
                    colorSelect.style.width = '110px';

                    const countLabel = document.createElement('span');
                    countLabel.textContent = 'Available:';

                    const countInput = document.createElement('input');
                    countInput.type = 'number';
                    countInput.min = '0';
                    countInput.value = '50';
                    countInput.style.width = '80px';

                    row.appendChild(labelSpan);
                    row.appendChild(colorSelect);
                    row.appendChild(countLabel);
                    row.appendChild(countInput);
                    container.appendChild(row);

                    chipColorRows.push({ colorSelect, countInput });

                    colorSelect.addEventListener('change', recalcAll);
                    countInput.addEventListener('input', recalcAll);
                }

                recalcAll();
            }

            chipColorsCountInput.addEventListener('input', rebuildRows);
            rebuildRows();
        }

        function getColorCounts() {
            const colorCounts = {};
            COLOR_OPTIONS.forEach(c => { colorCounts[c] = 0; });

            chipColorRows.forEach(row => {
                const color = row.colorSelect.value;
                const count = parseInt(row.countInput.value || '0', 10);
                if (!isNaN(count) && count > 0) {
                    colorCounts[color] += count;
                }
            });

            // Build array of used colors
            const used = [];
            COLOR_OPTIONS.forEach(color => {
                const count = colorCounts[color];
                if (count > 0) {
                    used.push({ name: color, count });
                }
            });

            return { colorCounts, usedColors: used };
        }

        function computeColorValues(usedColors) {
            // Base patterns by number of colors (typical "feel"):
            const basePatterns = {
                1: [25],
                2: [25, 100],
                3: [25, 100],
                4: [25, 100, 500, 1000],
                5: [25, 100, 500, 1000, 5000]
            };

            const n = usedColors.length;
            if (n === 0) return {};

            // Pick a base pattern of the right length
            const base = (basePatterns[n] || basePatterns[5].slice(0, n)).slice();

            // Map valueScaleStep to **integer-friendly** multipliers
            // No weird decimals: always multiply, then round to nearest 5.
            const scaleMultipliers = {
                '-2': 0.25,
                '-1': 0.5,
                '0': 1,
                '1': 2,
                '2': 4,
                '3': 8
            };
            const multiplier = scaleMultipliers[String(valueScaleStep)] ?? 1;

            const map = {};
            for (let i = 0; i < n; i++) {
                const colorName = usedColors[i].name;
                const raw = base[i] * multiplier;

                // âœ… round to nearest 5, never < 5, and always an integer
                let rounded = Math.round(raw / 5) * 5;
                if (rounded < 5) rounded = 5;

                map[colorName] = rounded;
            }
            return map;
        }

        // --- Chip usage + suggested starting stack ---
        function recalcChipUsageAndStacks() {
            const playersInput = document.getElementById('players');
            const helper = document.getElementById('stackUsageHelper');
            const summaryNote = document.getElementById('chipSummaryNote');
            const valueScaleLabel = document.getElementById('valueScaleLabel');

            const players = clamp(parseInt(playersInput.value || '0', 10), 1, 50);

            const { usedColors } = getColorCounts();
            const totalChips = usedColors.reduce((sum, c) => sum + c.count, 0);

            if (totalChips === 0 || !players) {
                helper.textContent = 'Enter chip counts and number of players to see a suggested stack.';
                summaryNote.textContent = 'No chip counts or players yet.';
                valueScaleLabel.textContent = 'Current values will be shown here after you enter chip colors.';
                currentStackSuggestion = null;
                return;
            }

            // Values follow the color order: White < Red < Green < Blue < Black
            const valueMap = computeColorValues(usedColors);

            // How aggressively we use the total chip pool
            const modeRadio = document.querySelector('input[name="stackUsageMode"]:checked');
            const mode = modeRadio ? modeRadio.value : 'half';
            const usageFractions = { some: 0.25, half: 0.5, most: 0.75, max: 0.9 };
            const fraction = usageFractions[mode] || 0.5;

            let chipsForStacks = Math.floor(totalChips * fraction);
            const minNeeded = players * MIN_CHIPS_PER_PLAYER;

            if (chipsForStacks < minNeeded) {
                chipsForStacks = Math.min(minNeeded, totalChips);
            }
            if (chipsForStacks <= 0) {
                helper.textContent = 'Not enough chips to build a starting stack.';
                summaryNote.textContent = `Total available chips: ${totalChips}.`;
                currentStackSuggestion = null;
                return;
            }

            const chipsPerPlayer = Math.floor(chipsForStacks / players);
            if (chipsPerPlayer < MIN_CHIPS_PER_PLAYER) {
                helper.textContent =
                    `Not enough chips for ${players} players. ` +
                    `Try reducing players or increasing chip counts.`;
                summaryNote.textContent =
                    `Total available chips: ${totalChips}. ` +
                    `Even distribution would give only ${chipsPerPlayer} chips per player.`;
                currentStackSuggestion = null;
                return;
            }

            // Build per-color structure sorted by "smallest to largest" (White..Black)
            const perPlayer = usedColors
                .map(c => ({
                    name: c.name,
                    value: valueMap[c.name],
                    available: c.count,
                    perPlayerCount: 0,
                    maxPerPlayer: Math.floor(c.count / players),
                    rank: COLOR_OPTIONS.indexOf(c.name)
                }))
                .sort((a, b) => a.rank - b.rank);

            const N = perPlayer.length;

            // ðŸŽ¯ Weight lower denominations more heavily
            // For up to 5 colors, use weights â‰ˆ [6, 4, 2, 1, 1].
            const baseWeightsAll = [6, 4, 2, 1, 1];
            const weights = perPlayer.map((c, idx) => baseWeightsAll[idx] ?? 1);
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);

            // First pass: target chips per color based on weights,
            // but cap by inventory (maxPerPlayer).
            let assignedTotal = 0;
            for (let i = 0; i < N; i++) {
                const w = weights[i];
                const ideal = Math.floor((chipsPerPlayer * w) / totalWeight);
                const cap = perPlayer[i].maxPerPlayer;
                const given = Math.min(ideal, cap);
                perPlayer[i].perPlayerCount = given;
                assignedTotal += given;
            }

            // Second pass: distribute leftover chips, starting from the smallest value up,
            // still respecting inventory caps.
            let leftover = chipsPerPlayer - assignedTotal;
            while (leftover > 0) {
                let addedThisLoop = 0;
                for (let i = 0; i < N && leftover > 0; i++) {
                    if (perPlayer[i].perPlayerCount < perPlayer[i].maxPerPlayer) {
                        perPlayer[i].perPlayerCount += 1;
                        leftover -= 1;
                        addedThisLoop += 1;
                    }
                }
                if (addedThisLoop === 0) break; // inventory exhausted
            }

            const totalValuePerPlayer = perPlayer.reduce(
                (sum, c) => sum + c.perPlayerCount * c.value,
                0
            );

            helper.textContent =
                `You have ${totalChips} chips across ${N} colors. Mode â€œ${mode}â€ uses about ` +
                `${chipsPerPlayer * players} chips total (~${chipsPerPlayer} per player).`;

            const valuePairs = perPlayer.map(c => `${c.name} = ${c.value}`).join(', ');
            valueScaleLabel.textContent = `Current chip values: ${valuePairs}`;

            summaryNote.textContent =
                `Suggested starting stack: ~${chipsPerPlayer} chips per player, ` +
                `worth about ${totalValuePerPlayer.toLocaleString()} in chip value.`;

            currentStackSuggestion = {
                chipsPerPlayer,
                totalValuePerPlayer,
                colors: perPlayer
            };
        }

        function calculateStructure() {
            const errorBox = document.getElementById('errorBox');
            errorBox.style.display = 'none';
            errorBox.textContent = '';

            const players = clamp(parseInt(document.getElementById('players').value || '0', 10), 1, 50);
            const runtimeHours = Math.max(0, parseFloat(document.getElementById('runtimeHours').value || '0'));

            if (!players || runtimeHours <= 0) {
                errorBox.style.display = 'block';
                errorBox.textContent = 'Please enter a valid number of players and runtime.';
                return null;
            }

            const useBreaks = document.getElementById('useBreaks').checked;
            const allowRebuys = document.getElementById('allowRebuys').checked;

            // --- Breaks & effective play time ---
            let breakMinutes = 0;
            let breakFrequencyHours = 0;
            let breaks = [];

            if (useBreaks) {
                breakMinutes = Math.max(0, parseInt(document.getElementById('breakMinutes').value || '0', 10));
                breakFrequencyHours = Math.max(0.25, parseFloat(document.getElementById('breakFrequencyHours').value || '0'));
                if (breakMinutes > 0) {
                    let t = breakFrequencyHours;
                    while (t < runtimeHours) {
                        breaks.push({ atHour: t, minutes: breakMinutes });
                        t += breakFrequencyHours;
                    }
                }
            }

            const totalBreakMinutes = breaks.reduce((sum, b) => sum + b.minutes, 0);
            let effectiveMinutes = runtimeHours * 60 - totalBreakMinutes;
            if (effectiveMinutes < 60) effectiveMinutes = 60;

            // --- Level length & count ---
            const levelMinutes = 12;
            let levelsCount = Math.floor(effectiveMinutes / levelMinutes);
            if (levelsCount < 4) levelsCount = 4; // at least a few levels

            // --- Starting stack value (per player) ---
            let startingStackValue = 8000;
            if (currentStackSuggestion && currentStackSuggestion.totalValuePerPlayer > 0) {
                startingStackValue = currentStackSuggestion.totalValuePerPlayer;
            }

            // --- Smallest chip value (for unit multiples) ---
            let chipValues = [];
            if (currentStackSuggestion && currentStackSuggestion.colors.length) {
                chipValues = currentStackSuggestion.colors.map(c => c.value);
            } else {
                chipValues = [25, 100, 500, 1000]; // generic fallback
            }
            const minChip = chipValues.length ? Math.min(...chipValues) : 25;

            // --- Option C: dynamic exponential blind curve ---
            // Start big blind at 2Ã— smallest chip
            let startBBRaw = minChip * 2;
                    
            // Pick target depth of average stack at the final level based on speed
            const speedEl = document.getElementById('structureSpeed');
            const speed = speedEl ? speedEl.value : 'normal';
            let targetAvgBBAtEnd;
                    
            if (speed === 'slow') {
              targetAvgBBAtEnd = 16;  // slower blind growth, deeper average stack
            } else if (speed === 'turbo') {
              targetAvgBBAtEnd = 8;   // faster blind growth, shallower avg stack
            } else {
              targetAvgBBAtEnd = 12;  // normal
            }
            
            let endBBRaw = startingStackValue / targetAvgBBAtEnd;


            // Make sure we actually grow (in case stack is tiny)
            if (endBBRaw < startBBRaw * 2) {
                endBBRaw = startBBRaw * 2;
            }

            let growthFactor = 1;
            if (levelsCount > 1) {
                growthFactor = Math.pow(endBBRaw / startBBRaw, 1 / (levelsCount - 1));
            }

            const schedule = [];
            let elapsed = 0;

            for (let i = 0; i < levelsCount; i++) {
                const level = i + 1;
                const levelStartMin = elapsed;
                const levelEndMin = elapsed + levelMinutes;

                // Raw BB for this level, then snap to chip units
                const bbRaw = startBBRaw * Math.pow(growthFactor, i);
                let bb = roundToUnit(bbRaw, minChip);
                let sb = roundToUnit(bb / 2, minChip);
                if (sb < minChip) sb = minChip;

                schedule.push({
                    level,
                    startMin: levelStartMin,
                    endMin: levelEndMin,
                    sb,
                    bb
                });

                elapsed += levelMinutes;
            }

            // --- Rebuy cutoff ---
            let rebuyCutoffHours = null;
            if (allowRebuys) {
                rebuyCutoffHours = Math.min(
                    runtimeHours,
                    Math.max(0.5, parseFloat(document.getElementById('rebuyCutoffHours').value || '0'))
                );
            }

            return {
                players,
                runtimeHours,
                useBreaks,
                breakMinutes,
                breakFrequencyHours,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                levelsCount,
                levelMinutes,
                schedule,
                startingStackValue
            };
        }

        function buildDisplaySchedule(structure) {
            const baseSchedule = structure.schedule || [];
            const breaks = structure.breaks || [];
            const allowRebuys = structure.allowRebuys;
            const rebuyCutoffHours = structure.rebuyCutoffHours;

            // Start with just the levels
            const rows = baseSchedule.map(l => ({
                type: 'level',
                level: l.level,
                startMin: l.startMin,
                endMin: l.endMin,
                sb: l.sb,
                bb: l.bb,
                note: ''
            }));

            // Attach breaks: place each break after the level whose midpoint
            // is closest to the requested break time.
            breaks.forEach(b => {
                const targetMinutes = b.atHour * 60;
                let closestIndex = 0;
                let bestDiff = Infinity;

                rows.forEach((r, idx) => {
                    if (r.type !== 'level') return;
                    const mid = (r.startMin + r.endMin) / 2;
                    const diff = Math.abs(mid - targetMinutes);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        closestIndex = idx;
                    }
                });

                // Insert a break row after that level
                rows.splice(closestIndex + 1, 0, {
                    type: 'break',
                    level: null,
                    startMin: null,
                    endMin: null,
                    sb: null,
                    bb: null,
                    note: `Break (${b.minutes} min)`
                });
            });

            // Attach rebuy cutoff note on the level whose midpoint is
            // closest to the rebuy cutoff hour.
            if (allowRebuys && rebuyCutoffHours) {
                const cutoffMinutes = rebuyCutoffHours * 60;
                let cutoffIdx = 0;
                let bestDiff = Infinity;

                rows.forEach((r, idx) => {
                    if (r.type !== 'level') return;
                    const mid = (r.startMin + r.endMin) / 2;
                    const diff = Math.abs(mid - cutoffMinutes);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        cutoffIdx = idx;
                    }
                });

                const r = rows[cutoffIdx];
                r.note += (r.note ? ' ' : '') + 'Rebuys end after this level.';
            }

            return rows;
        }

        // --- Preview rendering ---
        function renderPreview(structure) {
            const container = document.getElementById('previewContent');

            if (!structure) {
                container.innerHTML = '<p class="small-note muted">Fix errors on the left to see the preview.</p>';
                return;
            }

            const {
                players,
                runtimeHours,
                useBreaks,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                schedule,
                levelMinutes,
                startingStackValue
            } = structure;

            const runtimeStr = runtimeHours.toFixed(1).replace(/\.0$/, '');
            const metaHtml = `
        <div class="preview-section-title">Tournament Summary</div>
        <table>
          <tbody>
            <tr><td>Players</td><td>${players}</td></tr>
            <tr><td>Runtime</td><td>${runtimeStr} hours</td></tr>
            <tr><td>Level length</td><td>${levelMinutes} minutes</td></tr>
            <tr><td>Starting stack value</td><td>${startingStackValue.toLocaleString()}</td></tr>
          </tbody>
        </table>
      `;

            let startingStackHtml = '';
            if (currentStackSuggestion) {
                const stack = currentStackSuggestion;
                const rowsHtml = stack.colors
                    .filter(c => c.perPlayerCount > 0)
                    .map(c => {
                        const totalUsed = c.perPlayerCount * structure.players;
                        return `
              <tr>
                <td>${c.name}</td>
                <td>${c.value}</td>
                <td>${c.perPlayerCount}</td>
                <td>${totalUsed}</td>
              </tr>`;
                    })
                    .join('');

                startingStackHtml = `
          <div class="preview-section-title">Suggested Starting Stack (per player)</div>
          <span class="small-note">
            Approx. ${stack.chipsPerPlayer} chips per player, total value ~${stack.totalValuePerPlayer.toLocaleString()}.
          </span>
          <div class="scroll-box">
            <table>
              <thead>
                <tr>
                  <th>Color</th>
                  <th>Value</th>
                  <th>Chips / Player</th>
                  <th>Total Used</th>
                </tr>
              </thead>
              <tbody>${rowsHtml}</tbody>
            </table>
          </div>
        `;
            } else {
                startingStackHtml = `
          <div class="preview-section-title">Suggested Starting Stack (per player)</div>
          <span class="small-note muted">
            Define chip colors and counts to see a suggested stack.
          </span>
        `;
            }

            let breaksHtml = '';
            if (useBreaks && breaks.length) {
                const rows = breaks.map((b, idx) => {
                    const atMin = Math.round(b.atHour * 60);
                    return `<tr><td>Break ${idx + 1}</td><td>${b.minutes} min</td><td>${formatMinutes(atMin)}</td></tr>`;
                }).join('');
                breaksHtml = `
          <div class="preview-section-title">Breaks</div>
          <div class="scroll-box">
            <table>
              <thead>
                <tr><th>#</th><th>Length</th><th>Approx. Time</th></tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
          <span class="small-note">
            Total break time: ${totalBreakMinutes} minutes.
          </span>
        `;
            } else {
                breaksHtml = `
          <div class="preview-section-title">Breaks</div>
          <span class="small-note muted">
            No scheduled breaks, or break config not enabled.
          </span>
        `;
            }

            let rebuysHtml = '';
            if (allowRebuys && rebuyCutoffHours) {
                rebuysHtml = `
          <div class="preview-section-title">Rebuys</div>
          <span class="small-note">
            Rebuys allowed until ${rebuyCutoffHours.toFixed(1).replace(/\.0$/, '')} hours after start.
            Each rebuy uses the same stack as the initial buy-in.
          </span>
        `;
            } else {
                rebuysHtml = `
          <div class="preview-section-title">Rebuys</div>
          <span class="small-note muted">
            Rebuys disabled.
          </span>
        `;
            }

            const displayRows = buildDisplaySchedule(structure);

            const scheduleRows = displayRows.map(r => {
                if (r.type === 'level') {
                    return `
                  <tr>
                    <td>${r.level}</td>
                    <td>${formatMinutes(r.startMin)}</td>
                    <td>${formatMinutes(r.endMin)}</td>
                    <td>${r.sb}</td>
                    <td>${r.bb}</td>
                    <td>${r.note || ''}</td>
                  </tr>
                `;
                } else {
                    // break row
                    return `
                  <tr>
                    <td>â€”</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>${r.note || 'Break'}</td>
                  </tr>
                `;
                }
            }).join('');

            const scheduleHtml = `
              <div class="preview-section-title">Blind Schedule</div>
              <div class="scroll-box">
                <table>
                  <thead>
                    <tr>
                      <th>Lvl</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>SB</th>
                      <th>BB</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>${scheduleRows}</tbody>
                </table>
              </div>
            `;


            container.innerHTML = `
        ${metaHtml}
        ${startingStackHtml}
        ${breaksHtml}
        ${rebuysHtml}
        ${scheduleHtml}
      `;
        }

        function formatMinutes(min) {
            const h = Math.floor(min / 60);
            const m = min % 60;
            const hStr = h === 0 ? '0' : h.toString();
            const mStr = m.toString().padStart(2, '0');
            return `${hStr}:${mStr}`;
        }

        // --- PDF generation with beginner-friendly hand guide ---
        function generatePdf(structure) {
            if (!window.jspdf || !window.jspdf.jsPDF) {
                alert('PDF engine (jsPDF) did not load. Check your connection and try again.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'mm', format: 'a4' });

            const {
                players,
                runtimeHours,
                useBreaks,
                breaks,
                totalBreakMinutes,
                allowRebuys,
                rebuyCutoffHours,
                schedule,
                levelMinutes,
                startingStackValue
            } = structure;

            let y = 10;

            doc.setFontSize(18);
            doc.text('Home Poker Tournament Guide', 105, y, { align: 'center' });
            y += 8;
            doc.setFontSize(11);
            doc.text(
                `Players: ${players}   Runtime: ${runtimeHours.toFixed(1).replace(/\.0$/, '')} hours`,
                105,
                y,
                { align: 'center' }
            );
            y += 6;

            // Beginner-friendly hand ranking guide
            doc.setFontSize(13);
            doc.text('Hand Rankings (Strongest to Weakest)', 10, y);
            y += 5;
            doc.setFontSize(9);

            const handDescriptions = [
                {
                    title: 'Royal Flush',
                    desc: 'The combination of ten, jack, queen, king, ace, all of the same suit.'
                },
                {
                    title: 'Straight Flush',
                    desc: 'Five cards of the same suit in sequential order.'
                },
                {
                    title: 'Four of a Kind',
                    desc: 'Any four numerically matching cards.'
                },
                {
                    title: 'Full House',
                    desc: 'Combination of three of a kind and a pair in the same hand.'
                },
                {
                    title: 'Flush',
                    desc: 'Five cards of the same suit, in any order.'
                },
                {
                    title: 'Straight',
                    desc: 'Five cards of any suit, in sequential order.'
                },
                {
                    title: 'Three of a Kind',
                    desc: 'Any three numerically matching cards.'
                },
                {
                    title: 'Two Pair',
                    desc: 'Two different pairs in the same hand.'
                },
                {
                    title: 'One Pair',
                    desc: 'Any two numerically matching cards.'
                },
                {
                    title: 'High Card',
                    desc: 'No made hand; the highest card in your hand determines the winner.'
                }
            ];

            const maxWidth = 180; // mm
            handDescriptions.forEach(item => {
                const line = item.title + ': ' + item.desc;
                const wrapped = doc.splitTextToSize(line, maxWidth);
                doc.text(wrapped, 12, y);
                y += wrapped.length * 4;
            });

            y += 3;
            doc.setFontSize(12);
            doc.text('Tournament Summary', 10, y);
            y += 4;
            doc.setFontSize(10);
            doc.text(`Players: ${players}`, 12, y); y += 4;
            doc.text(`Runtime: ${runtimeHours.toFixed(1).replace(/\.0$/, '')} hours`, 12, y); y += 4;
            doc.text(`Level length: ${levelMinutes} minutes`, 12, y); y += 4;
            doc.text(`Starting stack value (approx.): ${startingStackValue.toLocaleString()}`, 12, y); y += 4;

            if (useBreaks && breaks.length) {
                doc.text(`Total break time: ${totalBreakMinutes} minutes`, 12, y); y += 4;
            } else {
                doc.text('Breaks: none scheduled', 12, y); y += 4;
            }

            if (allowRebuys && rebuyCutoffHours) {
                doc.text(
                    `Rebuys: allowed until ${rebuyCutoffHours.toFixed(1).replace(/\.0$/, '')} hours from start`,
                    12,
                    y
                );
                y += 4;
            } else {
                doc.text('Rebuys: not allowed', 12, y); y += 4;
            }

            // Suggested starting stack table
            if (currentStackSuggestion && currentStackSuggestion.colors.some(c => c.perPlayerCount > 0)) {
                y += 2;
                doc.setFontSize(12);
                doc.text('Suggested Starting Stack (per player)', 10, y);
                y += 2;

                if (doc.autoTable) {
                    doc.autoTable({
                        startY: y,
                        head: [['Color', 'Value', 'Chips / Player', 'Total Used']],
                        body: currentStackSuggestion.colors
                            .filter(c => c.perPlayerCount > 0)
                            .map(c => [
                                c.name,
                                String(c.value),
                                String(c.perPlayerCount),
                                String(c.perPlayerCount * players)
                            ]),
                        styles: { fontSize: 9 },
                        headStyles: { fillColor: [15, 23, 42] }
                    });
                    y = doc.lastAutoTable.finalY + 4;
                }
            }

            doc.setFontSize(12);
            doc.text('Blind Schedule', 10, y);
            y += 2;

            if (doc.autoTable) {
                const displayRows = buildDisplaySchedule(structure);

                doc.autoTable({
                    startY: y,
                    head: [['Lvl', 'Start', 'End', 'SB', 'BB', 'Note']],
                    body: displayRows.map(r => {
                        if (r.type === 'level') {
                            return [
                                String(r.level),
                                formatMinutes(r.startMin),
                                formatMinutes(r.endMin),
                                String(r.sb),
                                String(r.bb),
                                r.note || ''
                            ];
                        } else {
                            // break row
                            return ['â€”', '', '', '', '', r.note || 'Break'];
                        }
                    }),
                    styles: { fontSize: 9 },
                    headStyles: { fillColor: [15, 23, 42] }
                });
            }


            try {
                // Open PDF in a new tab/window (more reliable on iOS)
                doc.output('dataurlnewwindow');
            } catch (e) {
                alert('Error generating PDF: ' + (e && e.message ? e.message : e));
            }
        }
    </script>
</body>

</html>